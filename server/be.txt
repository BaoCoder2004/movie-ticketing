# ==================================================
# Path: D:\movie-ticketing\server
# Detected tech: javascript, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
server/
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ branches.js
‚îÇ   ‚îú‚îÄ‚îÄ catalog.js
‚îÇ   ‚îú‚îÄ‚îÄ exhibitors.js
‚îÇ   ‚îú‚îÄ‚îÄ holds.js
‚îÇ   ‚îú‚îÄ‚îÄ movies.js
‚îÇ   ‚îú‚îÄ‚îÄ orders.js
‚îÇ   ‚îú‚îÄ‚îÄ payments.js
‚îÇ   ‚îú‚îÄ‚îÄ refunds.js
‚îÇ   ‚îú‚îÄ‚îÄ reports.js
‚îÇ   ‚îú‚îÄ‚îÄ rooms.js
‚îÇ   ‚îú‚îÄ‚îÄ seats.js
‚îÇ   ‚îú‚îÄ‚îÄ showtimes.js
‚îÇ   ‚îú‚îÄ‚îÄ tickets.js
‚îÇ   ‚îú‚îÄ‚îÄ tmdb.js
‚îÇ   ‚îú‚îÄ‚îÄ users.js
‚îÇ   ‚îî‚îÄ‚îÄ vouchers.js
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ db.js
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ order_guard.js
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ package-lock.json
‚îî‚îÄ‚îÄ package.json
```

## FILE CONTENTS

### routes\branches.js
```js
// server/routes/branches.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

const bad = (res, code, message, status = 400, extra = {}) =>
  res.status(status).json({ error: code, message, ...extra });

// LIST
router.get('/branches', async (req, res) => {
  const exhibitorId = req.query.exhibitorId ? Number(req.query.exhibitorId) : null;
  const q = String(req.query.search || '').trim();
  const page = Math.max(1, Number(req.query.page || 1));
  const pageSize = Math.min(100, Math.max(1, Number(req.query.pageSize || 50)));
  const where = [], params = [];
  if (exhibitorId) { where.push('b.exhibitor_id=?'); params.push(exhibitorId); }
  if (q) { where.push('(b.name LIKE ? OR b.city LIKE ? OR b.address LIKE ?)'); params.push(`%${q}%`,`%${q}%`,`%${q}%`); }
  const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';

  const [[{ total }]] = await pool.query(`SELECT COUNT(*) total FROM branches b ${whereSql}`, params);
  const [rows] = await pool.query(
    `SELECT b.id,b.exhibitor_id,b.name,b.city,b.address,b.latitude,b.longitude,b.is_active
       FROM branches b
      ${whereSql}
      ORDER BY b.city ASC, b.name ASC
      LIMIT ? OFFSET ?`,
    [...params, pageSize, (page - 1) * pageSize]
  );
  res.json({
    page, pageSize, total,
    items: rows.map(r => ({
      id: Number(r.id),
      exhibitorId: Number(r.exhibitor_id),
      name: r.name,
      city: r.city || null,
      address: r.address || null,
      latitude: r.latitude != null ? Number(r.latitude) : null,
      longitude: r.longitude != null ? Number(r.longitude) : null,
      isActive: !!r.is_active
    }))
  });
});

// DETAIL
router.get('/branches/:id', async (req, res) => {
  const id = Number(req.params.id);
  const [[r]] = await pool.query(
    `SELECT id,exhibitor_id,name,city,address,latitude,longitude,is_active FROM branches WHERE id=?`, [id]
  );
  if (!r) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y', 404);
  res.json({
    id: Number(r.id),
    exhibitorId: Number(r.exhibitor_id),
    name: r.name, city: r.city || null, address: r.address || null,
    latitude: r.latitude != null ? Number(r.latitude) : null,
    longitude: r.longitude != null ? Number(r.longitude) : null,
    isActive: !!r.is_active
  });
});

// CREATE
router.post('/branches', async (req, res) => {
  const b = req.body || {};
  const exhibitorId = Number(b.exhibitorId || 0);
  const name = String(b.name || '').trim();
  const city = b.city || null;
  if (!exhibitorId || !name || !city) return bad(res, 'BAD_REQUEST', 'exhibitorId, name, city b·∫Øt bu·ªôc');

  // x√°c th·ª±c FK
  const [[ex]] = await pool.query('SELECT id FROM exhibitors WHERE id=?', [exhibitorId]);
  if (!ex) return bad(res, 'EXHIBITOR_NOT_FOUND', 'exhibitorId kh√¥ng t·ªìn t·∫°i', 400);

  try {
    const [r] = await pool.query(
      `INSERT INTO branches(exhibitor_id,name,city,address,latitude,longitude,is_active,created_at,updated_at)
       VALUES (?,?,?,?,?,?,?,UTC_TIMESTAMP(),UTC_TIMESTAMP())`,
      [
        exhibitorId,
        name,
        city,
        b.address || null,
        b.latitude === '' || b.latitude === null || b.latitude === undefined ? null : Number(b.latitude),
        b.longitude === '' || b.longitude === null || b.longitude === undefined ? null : Number(b.longitude),
        b.isActive === false ? 0 : 1
      ]
    );
    const id = Number(r.insertId);
    const [[row]] = await pool.query(
      `SELECT id,exhibitor_id,name,city,address,latitude,longitude,is_active FROM branches WHERE id=?`, [id]
    );
    res.json({
      id,
      exhibitorId: Number(row.exhibitor_id),
      name: row.name,
      city: row.city,
      address: row.address,
      latitude: row.latitude != null ? Number(row.latitude) : null,
      longitude: row.longitude != null ? Number(row.longitude) : null,
      isActive: !!row.is_active
    });
  } catch (e) {
    if (e && (e.code === 'ER_NO_REFERENCED_ROW_2' || e.errno === 1452))
      return bad(res, 'EXHIBITOR_NOT_FOUND', 'exhibitorId kh√¥ng t·ªìn t·∫°i', 400);
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// UPDATE
router.put('/branches/:id', async (req, res) => {
  const id = Number(req.params.id);
  const b = req.body || {};
  const fields = [], vals = [];
  const set = (c, v) => { fields.push(`${c}=?`); vals.push(v); };

  if (b.exhibitorId !== undefined) {
    const newEx = Number(b.exhibitorId || 0);
    if (!newEx) return bad(res, 'BAD_REQUEST', 'exhibitorId ph·∫£i h·ª£p l·ªá');
    const [[ex]] = await pool.query('SELECT id FROM exhibitors WHERE id=?', [newEx]);
    if (!ex) return bad(res, 'EXHIBITOR_NOT_FOUND', 'exhibitorId kh√¥ng t·ªìn t·∫°i', 400);
    set('exhibitor_id', newEx);
  }
  if (b.name !== undefined) set('name', String(b.name || '').trim());
  if (b.city !== undefined) set('city', b.city || null);
  if (b.address !== undefined) set('address', b.address || null);
  if (b.latitude !== undefined) set('latitude', b.latitude === '' || b.latitude === null ? null : Number(b.latitude));
  if (b.longitude !== undefined) set('longitude', b.longitude === '' || b.longitude === null ? null : Number(b.longitude));
  if (b.isActive !== undefined) set('is_active', b.isActive ? 1 : 0);
  if (!fields.length) return bad(res, 'BAD_REQUEST', 'Kh√¥ng c√≥ tr∆∞·ªùng ƒë·ªÉ c·∫≠p nh·∫≠t');

  fields.push('updated_at=UTC_TIMESTAMP()');

  try {
    const [r] = await pool.query(`UPDATE branches SET ${fields.join(', ')} WHERE id=?`, [...vals, id]);
    if (r.affectedRows === 0) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y', 404);
    const [[row]] = await pool.query(
      `SELECT id,exhibitor_id,name,city,address,latitude,longitude,is_active FROM branches WHERE id=?`, [id]
    );
    res.json({
      id: Number(row.id),
      exhibitorId: Number(row.exhibitor_id),
      name: row.name,
      city: row.city,
      address: row.address,
      latitude: row.latitude != null ? Number(row.latitude) : null,
      longitude: row.longitude != null ? Number(row.longitude) : null,
      isActive: !!row.is_active
    });
  } catch (e) {
    if (e && (e.code === 'ER_NO_REFERENCED_ROW_2' || e.errno === 1452))
      return bad(res, 'EXHIBITOR_NOT_FOUND', 'exhibitorId kh√¥ng t·ªìn t·∫°i', 400);
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// DELETE
router.delete('/branches/:id', async (req, res) => {
  const id = Number(req.params.id);
  try {
    const [[{ cnt }]] = await pool.query(`SELECT COUNT(*) cnt FROM rooms WHERE branch_id=?`, [id]);
    if (cnt > 0) return bad(res, 'BRANCH_IN_USE', 'ƒêang c√≥ ph√≤ng chi·∫øu', 409);
    const [r] = await pool.query(`DELETE FROM branches WHERE id=?`, [id]);
    if (r.affectedRows === 0) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y', 404);
    res.json({ deleted: true });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

module.exports = router;

```

### routes\catalog.js
```js
// server/routes/catalog.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db'); // mysql2/promise

// helpers
const bad = (res, code, message, status = 400, extra = {}) =>
  res.status(status).json({ error: code, message, ...extra });

const pad = n => (n < 10 ? '0' + n : '' + n);
function toMySQLDateTime(input) {
  if (!input) return null;
  const d = new Date(input);           // nh·∫≠n '2025-09-18T17:00:00.000Z'
  if (isNaN(d)) return null;
  // xu·∫•t UTC -> 'YYYY-MM-DD HH:MM:SS'
  return (
    d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + ' ' +
    pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds())
  );
}
function range(q) {
  return { from: toMySQLDateTime(q.from), to: toMySQLDateTime(q.to) };
}

// --- Seats theo ph√≤ng ---
router.get('/rooms/:id/seats', async (req, res) => {
  const id = Number(req.params.id);
  if (!Number.isInteger(id) || id <= 0) return bad(res, 'BAD_REQUEST', 'roomId kh√¥ng h·ª£p l·ªá');
  try {
    const [rows] = await pool.query(
      `SELECT s.id, s.row_label, s.col_number, s.seat_type, s.is_accessible
         FROM seats s
        WHERE s.room_id = ?
        ORDER BY s.row_label, s.col_number`,
      [id]
    );
    res.json(rows);
  } catch (e) { bad(res, 'SERVER_ERROR', e.message, 500); }
});

// --- Rooms theo r·∫°p (exhibitor) ---
router.get('/exhibitors/:id/rooms', async (req, res) => {
  const id = Number(req.params.id);
  if (!Number.isInteger(id) || id <= 0) return bad(res, 'BAD_REQUEST', 'exhibitorId kh√¥ng h·ª£p l·ªá');
  try {
    const [rows] = await pool.query(
      `SELECT r.id, r.name, r.format_type, r.capacity, r.is_active,
              b.id AS branch_id, b.name AS branch_name, b.city
         FROM rooms r
         JOIN branches b ON b.id = r.branch_id
        WHERE b.exhibitor_id = ?
        ORDER BY b.city, b.name, r.name`,
      [id]
    );
    res.json(rows);
  } catch (e) { bad(res, 'SERVER_ERROR', e.message, 500); }
});

// --- Su·∫•t chi·∫øu theo phim + kho·∫£ng th·ªùi gian ---
router.get('/movies/:id/showtimes', async (req, res) => {
  const movieId = Number(req.params.id);
  if (!Number.isInteger(movieId) || movieId <= 0) return bad(res, 'BAD_REQUEST', 'movieId kh√¥ng h·ª£p l·ªá');
  const { from, to } = range(req.query);
  try {
    const [rows] = await pool.query(
      `SELECT st.id, st.room_id, st.movie_id, st.start_at, st.end_at, st.base_price,
              r.name AS room_name, r.format_type,
              b.id AS branch_id, b.name AS branch_name, b.city,
              ex.id AS exhibitor_id, ex.name AS exhibitor_name
         FROM showtimes st
         JOIN rooms r    ON r.id = st.room_id
         JOIN branches b ON b.id = r.branch_id
         JOIN exhibitors ex ON ex.id = b.exhibitor_id
        WHERE st.movie_id = ?
          AND (? IS NULL OR st.start_at >= ?)
          AND (? IS NULL OR st.start_at <= ?)
        ORDER BY st.start_at ASC`,
      [movieId, from, from, to, to]
    );
    res.json({
      items: rows.map(x => ({
        id: Number(x.id),
        roomId: Number(x.room_id),
        movieId,
        startAt: x.start_at,
        endAt: x.end_at,
        basePrice: Number(x.base_price),
        roomName: x.room_name,
        formatType: x.format_type,
        branchId: Number(x.branch_id),
        branchName: x.branch_name,
        city: x.city,
        exhibitorId: Number(x.exhibitor_id),
        exhibitorName: x.exhibitor_name
      }))
    });
  } catch (e) { bad(res, 'SERVER_ERROR', e.message, 500); }
});

// --- R·∫°p/Chi nh√°nh ƒëang chi·∫øu phim + kho·∫£ng th·ªùi gian ---
router.get('/movies/:id/exhibitors', async (req, res) => {
  const movieId = Number(req.params.id);
  if (!Number.isInteger(movieId) || movieId <= 0) return bad(res, 'BAD_REQUEST', 'movieId kh√¥ng h·ª£p l·ªá');
  const { from, to } = range(req.query);
  try {
    const [rows] = await pool.query(
      `SELECT ex.id   AS exhibitor_id, ex.name AS exhibitor_name,
              b.id    AS branch_id,   b.name  AS branch_name, b.city,
              COUNT(st.id) AS showtimes
         FROM showtimes st
         JOIN rooms r    ON r.id = st.room_id
         JOIN branches b ON b.id = r.branch_id
         JOIN exhibitors ex ON ex.id = b.exhibitor_id
        WHERE st.movie_id = ?
          AND (? IS NULL OR st.start_at >= ?)
          AND (? IS NULL OR st.start_at <= ?)
        GROUP BY ex.id, ex.name, b.id, b.name, b.city
        ORDER BY ex.name, b.city, b.name`,
      [movieId, from, from, to, to]
    );
    res.json({
      items: rows.map(x => ({
        exhibitorId: Number(x.exhibitor_id),
        exhibitorName: x.exhibitor_name,
        branchId: Number(x.branch_id),
        branchName: x.branch_name,
        city: x.city,
        showtimes: Number(x.showtimes)
      }))
    });
  } catch (e) { bad(res, 'SERVER_ERROR', e.message, 500); }
});

module.exports = router;

```

### routes\exhibitors.js
```js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

const bad = (res, code, message, status = 400, extra = {}) =>
  res.status(status).json({ error: code, message, ...extra });

// LIST
router.get('/exhibitors', async (req, res) => {
  const q = String(req.query.search || '').trim();
  const page = Math.max(1, Number(req.query.page || 1));
  const pageSize = Math.min(50, Math.max(1, Number(req.query.pageSize || 20)));
  const where = q ? 'WHERE name LIKE ? OR code LIKE ?' : '';
  const params = q ? [`%${q}%`, `%${q}%`] : [];
  const [[{ total }]] = await pool.query(`SELECT COUNT(*) total FROM exhibitors ${where}`, params);
  const [rows] = await pool.query(
    `SELECT id,name,code,website FROM exhibitors ${where} ORDER BY name ASC LIMIT ? OFFSET ?`,
    [...params, pageSize, (page - 1) * pageSize]
  );
  res.json({
    page, pageSize, total,
    items: rows.map(r => ({
      id: Number(r.id),
      name: r.name,
      code: r.code || null,
      website: r.website || null
    }))
  });
});

// CREATE
router.post('/exhibitors', async (req, res) => {
  const b = req.body || {};
  const name = String(b.name || '').trim();
  if (!name) return bad(res, 'BAD_REQUEST', 'name b·∫Øt bu·ªôc');
  try {
    const [r] = await pool.query(
      `INSERT INTO exhibitors(name,code,website,created_at,updated_at)
       VALUES (?,?,?,UTC_TIMESTAMP(),UTC_TIMESTAMP())`,
      [name, b.code || null, b.website || null]
    );
    res.json({
      id: Number(r.insertId),
      name,
      code: b.code || null,
      website: b.website || null
    });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// ƒëo·∫°n UPDATE trong server/routes/exhibitors.js
router.put('/exhibitors/:id', async (req, res) => {
  const id = Number(req.params.id);
  const b = req.body || {};
  const fields = [], vals = [];
  const set = (c, v) => { fields.push(`${c}=?`); vals.push(v); };
  if (b.name !== undefined) set('name', String(b.name || '').trim());
  if (b.code !== undefined) set('code', b.code || null);
  if (b.website !== undefined) set('website', b.website || null);
  if (!fields.length) return bad(res, 'BAD_REQUEST', 'Kh√¥ng c√≥ tr∆∞·ªùng ƒë·ªÉ c·∫≠p nh·∫≠t');
  fields.push('updated_at=UTC_TIMESTAMP()');
  try {
    const [r] = await pool.query(
      `UPDATE exhibitors SET ${fields.join(', ')} WHERE id=?`,
      [...vals, id] // fix: tr∆∞·ªõc ƒë√¢y l√† [.vals, id]
    );
    if (r.affectedRows === 0) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y', 404);
    const [[row]] = await pool.query(`SELECT id,name,code,website FROM exhibitors WHERE id=?`, [id]);
    res.json({
      id: Number(row.id),
      name: row.name,
      code: row.code || null,
      website: row.website || null
    });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// DELETE
router.delete('/exhibitors/:id', async (req, res) => {
  const id = Number(req.params.id);
  try {
    const [[{ cnt }]] = await pool.query(
      `SELECT COUNT(*) cnt FROM branches WHERE exhibitor_id=?`, [id]
    );
    if (cnt > 0) return bad(res, 'EXHIBITOR_IN_USE', 'ƒêang c√≥ chi nh√°nh', 409);
    const [r] = await pool.query(`DELETE FROM exhibitors WHERE id=?`, [id]);
    if (r.affectedRows === 0) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y', 404);
    res.json({ deleted: true });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// üìå NEW: GET /exhibitors/:id/movies
router.get('/exhibitors/:id/movies', async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');

  const [rows] = await pool.query(
    `SELECT DISTINCT m.id, m.title, m.poster_url, COUNT(st.id) AS showtimes
     FROM movies m
     JOIN showtimes st ON st.movie_id = m.id
     JOIN rooms r ON r.id = st.room_id
     JOIN branches b ON b.id = r.branch_id
     WHERE b.exhibitor_id = ?
     GROUP BY m.id, m.title, m.poster_url
     ORDER BY m.title`,
    [id]
  );
  res.json({
    items: rows.map(r => ({
      id: r.id,
      title: r.title,
      posterUrl: r.poster_url,
      showtimes: Number(r.showtimes)
    }))
  });
});

module.exports = router;

```

### routes\holds.js
```js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

const HOLD_MIN = Number(process.env.HOLD_MINUTES || 10);

function bad(res, code, message, extra = {}, status = 400) {
  return res.status(status).json({ error: code, message, ...extra });
}

function formatDatetimeUTC(d) {
  const pad = n => String(n).padStart(2, '0');
  return `${d.getUTCFullYear()}-${pad(d.getUTCMonth() + 1)}-${pad(d.getUTCDate())} ${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}:${pad(d.getUTCSeconds())}`;
}

router.post('/holds', async (req, res) => {
  const { showtimeId, seatIds, userId = null } = req.body || {};
  const showId = Number(showtimeId);
  const seatIdsClean = Array.from(new Set((seatIds || []).map(Number)))
    .filter(n => Number.isInteger(n) && n > 0);

  if (!showId || seatIdsClean.length === 0) {
    return bad(res, 'BAD_REQUEST', 'showtimeId v√† seatIds l√† b·∫Øt bu·ªôc');
  }

  const conn = await pool.getConnection();
  try {
    await conn.beginTransaction();

    const inMarks = seatIdsClean.map(() => '?').join(',');

    await conn.execute(
      `DELETE FROM seat_holds 
       WHERE expire_at <= UTC_TIMESTAMP() AND showtime_id = ? AND seat_id IN (${inMarks})`,
      [showId, ...seatIdsClean]
    );

    const [heldRows] = await conn.execute(
      `SELECT seat_id, 'HELD' AS reason 
         FROM seat_holds 
        WHERE showtime_id = ? AND seat_id IN (${inMarks})`,
      [showId, ...seatIdsClean]
    );

    const [ticketRows] = await conn.execute(
      `SELECT seat_id, 'TICKETED' AS reason 
         FROM tickets 
        WHERE showtime_id = ? AND seat_id IN (${inMarks})
          AND status IN ('ISSUED','SCANNED')`,
      [showId, ...seatIdsClean]
    );

    const conflicts = [...heldRows, ...ticketRows].map(r => ({
      seatId: Number(r.seat_id),
      reason: r.reason
    }));
    if (conflicts.length > 0) {
      await conn.rollback();
      return bad(res, 'SEATS_UNAVAILABLE', 'M·ªôt ho·∫∑c nhi·ªÅu gh·∫ø kh√¥ng kh·∫£ d·ª•ng', { conflicts }, 409);
    }

    // ‚úÖ T√≠nh expire_at ƒë√∫ng chu·∫©n UTC DATETIME
    const expireAtStr = formatDatetimeUTC(new Date(Date.now() + HOLD_MIN * 60000));
    const values = seatIdsClean.map(seatId => [showId, seatId, userId, expireAtStr]);
    const placeholders = values.map(() => '(?, ?, ?, ?)').join(',');

    await conn.execute(
      `INSERT INTO seat_holds (showtime_id, seat_id, user_id, expire_at) VALUES ${placeholders}`,
      values.flat()
    );

    const [created] = await conn.execute(
      `SELECT id, seat_id AS seatId, expire_at AS expireAt 
         FROM seat_holds 
        WHERE showtime_id = ? AND seat_id IN (${inMarks})`,
      [showId, ...seatIdsClean]
    );

    await conn.commit();

    const items = created.map(r => ({
      id: Number(r.id),
      seatId: Number(r.seatId),
      expireAt: new Date(r.expireAt).toISOString()
    }));
    return res.json({ showtimeId: showId, created: items, holdMinutes: HOLD_MIN });
  } catch (e) {
    try { await conn.rollback(); } catch {}
    return bad(res, 'INTERNAL', e.message, {}, 500);
  } finally {
    conn.release();
  }
});

router.get('/holds', async (req, res) => {
  const showtimeId = Number(req.query.showtimeId);
  if (!showtimeId) return bad(res, 'BAD_REQUEST', 'showtimeId l√† b·∫Øt bu·ªôc');
  try {
    await pool.execute(
      `DELETE FROM seat_holds WHERE expire_at <= UTC_TIMESTAMP() AND showtime_id = ?`,
      [showtimeId]
    );
    const [rows] = await pool.execute(
      `SELECT id, seat_id AS seatId, expire_at AS expireAt 
         FROM seat_holds 
        WHERE showtime_id = ? AND expire_at > UTC_TIMESTAMP()
        ORDER BY expire_at, seat_id`,
      [showtimeId]
    );
    const now = Date.now();
    const holds = rows.map(r => {
      const exp = new Date(r.expireAt);
      const remainingSec = Math.max(0, Math.floor((exp.getTime() - now) / 1000));
      return { id: Number(r.id), seatId: Number(r.seatId), expireAt: exp.toISOString(), remainingSec };
    });
    res.setHeader('Cache-Control', 'no-store');
    res.json({ showtimeId, holds });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, {}, 500);
  }
});

router.delete('/holds/:id', async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');
  try {
    const [r] = await pool.execute(`DELETE FROM seat_holds WHERE id = ?`, [id]);
    res.json({ deleted: Number(r.affectedRows || 0) });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, {}, 500);
  }
});

module.exports = router;

```

### routes\movies.js
```js
// server/routes/movies.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

const TMDB_IMG_W500 = 'https://image.tmdb.org/t/p/w500';

function bad(res, code, message, status = 400, extra = {}) {
  return res.status(status).json({ error: code, message, ...extra });
}
const normDate = (d) => {
  if (!d) return null;
  const s = String(d).slice(0, 10);
  return /^\d{4}-\d{2}-\d{2}$/.test(s) ? s : null;
};
function mapMovieRow(r) {
  return {
    id: Number(r.id),
    tmdbId: r.tmdb_id ?? null,
    title: r.title,
    status: r.status,
    durationMin: r.duration_min != null ? Number(r.duration_min) : 0,
    ratingAge: r.rating_age || null,
    genres: r.genres || null,
    releaseDate: r.release_date ? new Date(r.release_date).toISOString().slice(0, 10) : null,
    trailerUrl: r.trailer_url || null,
    description: r.description || null,
    imdbId: r.imdb_id || null,
    originalTitle: r.original_title || null,
    originalLanguage: r.original_language || null,
    posterPath: r.poster_path || null,
    backdropPath: r.backdrop_path || null,
    popularity: r.popularity != null ? Number(r.popularity) : null,
    voteAverage: r.vote_average != null ? Number(r.vote_average) : null,
    voteCount: r.vote_count != null ? Number(r.vote_count) : null,
    createdAt: r.created_at ? new Date(r.created_at).toISOString() : null,
    updatedAt: r.updated_at ? new Date(r.updated_at).toISOString() : null,
    posterUrl: r.poster_path ? `${TMDB_IMG_W500}${r.poster_path}` : null,
    backdropUrl: r.backdrop_path ? `${TMDB_IMG_W500}${r.backdrop_path}` : null,
  };
}

// LIST
router.get('/movies', async (req, res) => {
  const q = String(req.query.search || '').trim();
  const page = Math.max(1, Number(req.query.page || 1));
  const pageSize = Math.min(50, Math.max(1, Number(req.query.pageSize || 12)));
  const fields = String(req.query.fields || 'minimal').toLowerCase();

  const where = q ? `WHERE title LIKE ?` : '';
  const params = q ? [`%${q}%`] : [];

  const [[{ total }]] = await pool.query(`SELECT COUNT(*) total FROM movies ${where}`, params);

  const selectMinimal = `id, title, duration_min, poster_path`;
  const selectAll = `id, tmdb_id, title, status, duration_min, rating_age, genres, release_date, trailer_url, description,
                     imdb_id, original_title, original_language, poster_path, backdrop_path, popularity, vote_average, vote_count,
                     created_at, updated_at`;

  const [rows] = await pool.query(
    `SELECT ${fields === 'all' ? selectAll : selectMinimal} FROM movies ${where} ORDER BY id DESC LIMIT ? OFFSET ?`,
    q ? [...params, pageSize, (page - 1) * pageSize] : [pageSize, (page - 1) * pageSize]
  );

  res.json({
    page, pageSize, total,
    items: rows.map(r => (fields === 'all'
      ? mapMovieRow(r)
      : ({
          id: Number(r.id),
          title: r.title,
          durationMin: Number(r.duration_min || 0),
          posterUrl: r.poster_path ? `${TMDB_IMG_W500}${r.poster_path}` : null
        })))
  });
});

// DETAIL (full)
router.get('/movies/:id', async (req, res) => {
  const id = Number(req.params.id);
  const [[m]] = await pool.query(
    `SELECT id, tmdb_id, title, status, duration_min, rating_age, genres, release_date, trailer_url, description,
            imdb_id, original_title, original_language, poster_path, backdrop_path, popularity, vote_average, vote_count,
            created_at, updated_at
       FROM movies WHERE id = ?`, [id]
  );
  if (!m) return bad(res, 'NOT_FOUND', 'Kh√¥ng c√≥ phim', 404);

  const [videos] = await pool.query(
    `SELECT site, kind, key_or_url, published_at FROM movie_videos WHERE movie_id=? ORDER BY published_at DESC, id DESC`,
    [id]
  );

  const dto = mapMovieRow(m);
  dto.videos = videos.map(v => ({
    site: v.site, kind: v.kind, key: v.key_or_url,
    publishedAt: v.published_at ? new Date(v.published_at).toISOString() : null
  }));

  res.json(dto);
});

// CREATE
router.post('/movies', async (req, res) => {
  try {
    const b = req.body || {};
    const title = String(b.title || '').trim();
    const status = ['NOW', 'SOON'].includes(b.status) ? b.status : 'NOW';
    const duration = Math.max(0, Number(b.durationMin || 0));
    if (!title || !duration) return bad(res, 'BAD_REQUEST', 'title v√† durationMin l√† b·∫Øt bu·ªôc');

    const [r] = await pool.query(
      `INSERT INTO movies
       (tmdb_id, title, status, duration_min, rating_age, genres, release_date, trailer_url, description,
        imdb_id, original_title, original_language, poster_path, backdrop_path, popularity, vote_average, vote_count,
        created_at, updated_at)
       VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,UTC_TIMESTAMP(),UTC_TIMESTAMP())`,
      [
        b.tmdbId || null, title, status, duration, b.ratingAge || null, b.genres || null,
        normDate(b.releaseDate), b.trailerUrl || null, b.description || null,
        b.imdbId || null, b.originalTitle || null, b.originalLanguage || null,
        b.posterPath || null, b.backdropPath || null,
        b.popularity ?? null, b.voteAverage ?? null, b.voteCount ?? null
      ]
    );
    const [[row]] = await pool.query(`SELECT * FROM movies WHERE id=?`, [r.insertId]);
    res.json(mapMovieRow(row));
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// UPDATE
router.put('/movies/:id', async (req, res) => {
  const id = Number(req.params.id);
  const b = req.body || {};
  const [[exists]] = await pool.query(`SELECT id FROM movies WHERE id=?`, [id]);
  if (!exists) return bad(res, 'NOT_FOUND', 'Kh√¥ng c√≥ phim', 404);

  const fields = [];
  const vals = [];
  const set = (col, val) => { fields.push(`${col}=?`); vals.push(val); };

  if (b.tmdbId !== undefined) set('tmdb_id', b.tmdbId || null);
  if (b.title !== undefined) set('title', String(b.title).trim());
  if (b.status !== undefined) set('status', ['NOW','SOON'].includes(b.status)?b.status:'NOW');
  if (b.durationMin !== undefined) set('duration_min', Math.max(0, Number(b.durationMin || 0)));
  if (b.ratingAge !== undefined) set('rating_age', b.ratingAge || null);
  if (b.genres !== undefined) set('genres', b.genres || null);
  if (b.releaseDate !== undefined) set('release_date', normDate(b.releaseDate));
  if (b.trailerUrl !== undefined) set('trailer_url', b.trailerUrl || null);
  if (b.description !== undefined) set('description', b.description || null);
  if (b.imdbId !== undefined) set('imdb_id', b.imdbId || null);
  if (b.originalTitle !== undefined) set('original_title', b.originalTitle || null);
  if (b.originalLanguage !== undefined) set('original_language', b.originalLanguage || null);
  if (b.posterPath !== undefined) set('poster_path', b.posterPath || null);
  if (b.backdropPath !== undefined) set('backdrop_path', b.backdropPath || null);
  if (b.popularity !== undefined) set('popularity', b.popularity ?? null);
  if (b.voteAverage !== undefined) set('vote_average', b.voteAverage ?? null);
  if (b.voteCount !== undefined) set('vote_count', b.voteCount ?? null);

  if (!fields.length) return bad(res, 'BAD_REQUEST', 'Kh√¥ng c√≥ tr∆∞·ªùng ƒë·ªÉ c·∫≠p nh·∫≠t');
  fields.push('updated_at=UTC_TIMESTAMP()');

  await pool.query(`UPDATE movies SET ${fields.join(', ')} WHERE id=?`, [...vals, id]);

  const [[row]] = await pool.query(`SELECT * FROM movies WHERE id=?`, [id]);
  res.json(mapMovieRow(row));
});

// DELETE
router.delete('/movies/:id', async (req, res) => {
  const id = Number(req.params.id);
  try {
    const [r] = await pool.query(`DELETE FROM movies WHERE id=?`, [id]);
    if (r.affectedRows === 0) return bad(res, 'NOT_FOUND', 'Kh√¥ng c√≥ phim', 404);
    res.json({ deleted: true });
  } catch (e) {
    if (e && (e.code === 'ER_ROW_IS_REFERENCED_2' || e.errno === 1451)) {
      return bad(res, 'MOVIE_IN_USE', 'Kh√¥ng th·ªÉ x√≥a v√¨ ƒëang ƒë∆∞·ª£c d√πng', 409);
    }
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

module.exports = router;

```

### routes\orders.js
```js
// server/routes/orders.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

const REFUND_WINDOW_HOURS = Number(process.env.REFUND_WINDOW_HOURS || 2);

const ALLOWED = new Set(['pending','confirmed','expired','canceled']);
const toLowerStatus = s => {
  const v = String(s || '').trim().toLowerCase();
  return ALLOWED.has(v) ? v : '';
};

function bad(res, code, message, status = 400, extra = {}) {
  return res.status(status).json({ error: code, message, ...extra });
}

function toOrderRow(o){
  return {
    id: Number(o.id),
    orderCode: o.order_code || null,
    userId: o.user_id != null ? Number(o.user_id) : null,
    userEmail: o.user_email || null,
    userName: o.user_name || null,
    status: o.status,
    subtotal: Number(o.subtotal || 0),
    discount: Number(o.discount || 0),
    total: Number(o.total || 0),
    createdAt: o.created_at ? new Date(o.created_at).toISOString() : null,
    refundable: !!o.refundable,
  };
}

/* ===================== LIST ===================== */
router.get('/orders', async (req, res) => {
  try {
    const q = String(req.query.q || '').trim();
    const status = toLowerStatus(req.query.status);
    const page = Math.max(1, Number(req.query.page || 1));
    const pageSize = Math.min(100, Math.max(1, Number(req.query.pageSize || 50)));
    const where = [];
    const args = [];

    if (q) {
      where.push('(o.order_code LIKE ? OR u.email LIKE ? OR u.name LIKE ?)');
      args.push(`%${q}%`, `%${q}%`, `%${q}%`);
    }
    if (status) {
      where.push('o.status = ?');
      args.push(status);
    }
    const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';

    const [[{ total }]] = await pool.query(
      `SELECT COUNT(*) AS total
         FROM orders o
         LEFT JOIN users u ON u.id = o.user_id
        ${whereSql}`,
      args
    );

    const [rows] = await pool.query(
      `SELECT o.id,o.order_code,o.user_id,o.status,o.subtotal,o.discount,o.total,o.created_at,
              u.email AS user_email, u.name AS user_name,
              CASE
                WHEN o.status='confirmed' AND (
                  SELECT TIMESTAMPDIFF(HOUR, UTC_TIMESTAMP(), MIN(st.start_at))
                    FROM order_items oi
                    JOIN tickets t    ON t.id = oi.ref_id AND oi.kind='TICKET'
                    JOIN showtimes st ON st.id = t.showtime_id
                   WHERE oi.order_id = o.id
                ) >= ? THEN 1 ELSE 0
              END AS refundable
         FROM orders o
         LEFT JOIN users u ON u.id = o.user_id
        ${whereSql}
        ORDER BY o.id DESC
        LIMIT ? OFFSET ?`,
      [...args, REFUND_WINDOW_HOURS, pageSize, (page - 1) * pageSize]
    );

    res.json({ page, pageSize, total: Number(total || 0), items: rows.map(toOrderRow) });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

/* ===================== DETAIL ===================== */
router.get('/orders/:id', async (req, res) => {
  const id = Number(req.params.id);
  if (!Number.isInteger(id) || id <= 0) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');

  try {
    const [[o]] = await pool.query(
      `SELECT o.id,o.order_code,o.user_id,o.status,o.subtotal,o.discount,o.total,o.created_at,
              u.email AS user_email, u.name AS user_name
         FROM orders o
         LEFT JOIN users u ON u.id = o.user_id
        WHERE o.id=?`,
      [id]
    );
    if (!o) return bad(res, 'NOT_FOUND', 'Order kh√¥ng t·ªìn t·∫°i', 404);

    const [ticketsRows] = await pool.query(
      `SELECT t.id AS ticket_id, t.showtime_id, t.seat_id, t.qr_code, t.scanned_at, t.status AS ticket_status,
              s.row_label, s.col_number,
              st.start_at, st.end_at,
              m.title AS movie_title, r.name AS room_name
         FROM order_items oi
         JOIN tickets t    ON t.id = oi.ref_id AND oi.kind='TICKET'
         JOIN showtimes st ON st.id = t.showtime_id
         JOIN rooms r      ON r.id = st.room_id
         JOIN movies m     ON m.id = st.movie_id
         JOIN seats s      ON s.id = t.seat_id
        WHERE oi.order_id=?
        ORDER BY oi.id`,
      [id]
    );

    const [payments] = await pool.query(
      `SELECT id, provider, status, amount, created_at
         FROM payments
        WHERE order_id=?
        ORDER BY id DESC`,
      [id]
    );

    const [[timing]] = await pool.query(
      `SELECT MIN(st.start_at) AS min_start
         FROM order_items oi
         JOIN tickets t    ON t.id = oi.ref_id AND oi.kind='TICKET'
         JOIN showtimes st ON st.id = t.showtime_id
        WHERE oi.order_id=?`,
      [id]
    );
    const minStartAt = timing?.min_start ? new Date(timing.min_start).toISOString() : null;

    let refundable = false;
    if (o.status === 'confirmed' && minStartAt) {
      const hrs = (new Date(minStartAt).getTime() - Date.now()) / 36e5;
      refundable = hrs >= REFUND_WINDOW_HOURS;
    }

    res.json({
      ...toOrderRow(o),
      items: {
        tickets: ticketsRows.map(t => ({
          id: Number(t.ticket_id),
          showtimeId: Number(t.showtime_id),
          seatId: Number(t.seat_id),
          seatLabel: `${t.row_label}${t.col_number}`,
          movieTitle: t.movie_title,
          roomName: t.room_name,
          startAt: t.start_at ? new Date(t.start_at).toISOString() : null,
          endAt: t.end_at ? new Date(t.end_at).toISOString() : null,
          qrCode: t.qr_code || null,
          status: t.ticket_status || null,
          scannedAt: t.scanned_at ? new Date(t.scanned_at).toISOString() : null
        }))
      },
      payments: payments.map(p => ({
        id: Number(p.id),
        provider: p.provider,
        // DB values: INITIATED | SUCCESS | FAILED | REFUNDED
        status: String(p.status || '').toLowerCase(),
        amount: Number(p.amount || 0),
        createdAt: p.created_at ? new Date(p.created_at).toISOString() : null
      })),
      minStartAt, refundable
    });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

/* ===================== CANCEL ===================== */
router.patch('/orders/:id/cancel', async (req, res) => {
  const id = Number(req.params.id);
  if (!Number.isInteger(id) || id <= 0) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');

  const conn = await pool.getConnection();
  try {
    await conn.beginTransaction();

    const [[o]] = await conn.query(
      `SELECT id,status,expires_at FROM orders WHERE id=? FOR UPDATE`,
      [id]
    );
    if (!o) { await conn.rollback(); return bad(res,'NOT_FOUND','Kh√¥ng t√¨m th·∫•y order',404); }
    if (o.status !== 'pending') { await conn.rollback(); return bad(res,'INVALID_STATE','Ch·ªâ h·ªßy ƒë∆°n pending',409); }

    await conn.query(
      `UPDATE orders SET status='canceled', updated_at=UTC_TIMESTAMP() WHERE id=?`,
      [id]
    );

    await conn.commit();
    res.json({ id, canceled: true });
  } catch (e) {
    await conn.rollback();
    return bad(res, 'INTERNAL', e.message, 500);
  } finally { conn.release(); }
});

/* ===================== REFUND ===================== */
router.post('/orders/:id/refund', async (req, res) => {
  const id = Number(req.params.id);
  if (!Number.isInteger(id) || id <= 0) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');

  const conn = await pool.getConnection();
  try {
    await conn.beginTransaction();

    const [[o]] = await conn.query(
      `SELECT id,status,total FROM orders WHERE id=? FOR UPDATE`,
      [id]
    );
    if (!o) { await conn.rollback(); return bad(res,'NOT_FOUND','Kh√¥ng t√¨m th·∫•y order',404); }
    if (o.status !== 'confirmed') { await conn.rollback(); return bad(res,'INVALID_STATE','Ch·ªâ ho√†n ti·ªÅn ƒë∆°n confirmed',409); }

    const [[timing]] = await conn.query(
      `SELECT MIN(st.start_at) AS min_start
         FROM order_items oi
         JOIN tickets t    ON t.id = oi.ref_id AND oi.kind='TICKET'
         JOIN showtimes st ON st.id = t.showtime_id
        WHERE oi.order_id=?`,
      [id]
    );
    if (timing && timing.min_start) {
      const [[okRow]] = await conn.query(
        `SELECT CASE WHEN TIMESTAMPDIFF(HOUR, UTC_TIMESTAMP(), ?) >= ? THEN 1 ELSE 0 END AS ok`,
        [timing.min_start, REFUND_WINDOW_HOURS]
      );
      if (!okRow.ok) { await conn.rollback(); return bad(res,'REFUND_WINDOW_EXCEEDED',`Ch·ªâ ho√†n ti·ªÅn tr∆∞·ªõc ${REFUND_WINDOW_HOURS} gi·ªù`,409); }
    }

    await conn.query(
      `UPDATE payments SET status='REFUNDED', pay_date=UTC_TIMESTAMP()
        WHERE order_id=? AND status='SUCCESS'`,
      [id]
    );

    await conn.query(
      `UPDATE orders SET status='canceled', updated_at=UTC_TIMESTAMP() WHERE id=?`,
      [id]
    );

    await conn.commit();
    res.json({ id, refunded: true, amount: Number(o.total || 0) });
  } catch (e) {
    await conn.rollback();
    return bad(res, 'INTERNAL', e.message, 500);
  } finally { conn.release(); }
});

/* ===================== APPLY VOUCHER ===================== */
/**
 * POST /api/orders/:id/apply-voucher
 * body: { code: string }
 * Y√™u c·∫ßu: ƒë∆°n ƒëang pending. Voucher c√≤n hi·ªáu l·ª±c. T√≠nh discount v√† c·∫≠p nh·∫≠t orders(total).
 * B·∫£ng gi·∫£ ƒë·ªãnh:
 *   vouchers(id, code, type ENUM('PERCENT','AMOUNT'), value, max_discount, is_active, start_at, expiry_at, quota, per_user_limit)
 *   voucher_usages(id, voucher_id, order_id, user_id, amount, created_at)
 */
router.post('/orders/:id/apply-voucher', async (req, res) => {
  const id = Number(req.params.id);
  const code = String(req.body?.code || '').trim();
  if (!Number.isInteger(id) || id <= 0 || !code) return bad(res, 'BAD_REQUEST', 'Thi·∫øu id ho·∫∑c code');

  const conn = await pool.getConnection();
  try {
    await conn.beginTransaction();

    const [[o]] = await conn.query(
      `SELECT id,user_id,status,subtotal,discount,total FROM orders WHERE id=? FOR UPDATE`,
      [id]
    );
    if (!o) { await conn.rollback(); return bad(res,'NOT_FOUND','Order kh√¥ng t·ªìn t·∫°i',404); }
    if (o.status !== 'pending') { await conn.rollback(); return bad(res,'INVALID_STATE','Ch·ªâ √°p voucher cho ƒë∆°n pending',409); }

    const [[v]] = await conn.query(
      `SELECT id, code, type, value, COALESCE(max_discount,0) AS max_discount,
              is_active, start_at, expiry_at, COALESCE(quota,0) AS quota, COALESCE(per_user_limit,0) AS per_user_limit
         FROM vouchers
        WHERE code = ? FOR UPDATE`,
      [code]
    );
    if (!v) { await conn.rollback(); return bad(res,'INVALID_VOUCHER','M√£ kh√¥ng t·ªìn t·∫°i',404); }
    if (!v.is_active) { await conn.rollback(); return bad(res,'INVALID_VOUCHER','M√£ ƒë√£ kh√≥a',409); }
    if (v.start_at && new Date(v.start_at) > new Date()) { await conn.rollback(); return bad(res,'INVALID_VOUCHER','Ch∆∞a ƒë·∫øn th·ªùi gian √°p d·ª•ng',409); }
    if (v.expiry_at && new Date(v.expiry_at) < new Date()) { await conn.rollback(); return bad(res,'INVALID_VOUCHER','M√£ ƒë√£ h·∫øt h·∫°n',409); }

    // quota t·ªïng v√† quota theo user
    const [[{ usedTotal }]] = await conn.query(
      `SELECT COUNT(*) AS usedTotal FROM voucher_usages WHERE voucher_id=?`,
      [v.id]
    );
    if (v.quota && usedTotal >= v.quota) { await conn.rollback(); return bad(res,'QUOTA_EXCEEDED','H·∫øt l∆∞·ª£t s·ª≠ d·ª•ng',409); }

    const [[{ usedByUser }]] = await conn.query(
      `SELECT COUNT(*) AS usedByUser FROM voucher_usages WHERE voucher_id=? AND user_id=?`,
      [v.id, o.user_id]
    );
    if (v.per_user_limit && usedByUser >= v.per_user_limit) {
      await conn.rollback(); return bad(res,'USER_LIMIT_EXCEEDED','B·∫°n ƒë√£ d√πng h·∫øt l∆∞·ª£t cho m√£ n√†y',409);
    }

    // t√≠nh gi·∫£m
    const subtotal = Number(o.subtotal || 0);
    let discount = 0;
    if (v.type === 'PERCENT') {
      discount = Math.floor(subtotal * Number(v.value || 0) / 100);
      if (v.max_discount) discount = Math.min(discount, Number(v.max_discount));
    } else { // AMOUNT
      discount = Math.min(subtotal, Number(v.value || 0));
    }
    const total = Math.max(0, subtotal - discount);

    await conn.query(
      `UPDATE orders SET discount=?, total=?, updated_at=UTC_TIMESTAMP() WHERE id=?`,
      [discount, total, id]
    );

    await conn.query(
      `INSERT INTO voucher_usages(voucher_id, order_id, user_id, amount, created_at)
       VALUES(?,?,?,?,UTC_TIMESTAMP())`,
      [v.id, id, o.user_id, discount]
    );

    await conn.commit();
    res.json({ id, code: v.code, discount, total });
  } catch (e) {
    await conn.rollback();
    return bad(res, 'INTERNAL', e.message, 500);
  } finally { conn.release(); }
});

/* ===================== CONFIRM (ISSUE TICKETS) ===================== */
/**
 * POST /api/orders/:id/confirm
 * ƒêi·ªÅu ki·ªán:
 *  - ƒë∆°n pending v√† ch∆∞a h·∫øt h·∫°n
 *  - c√≥ √≠t nh·∫•t m·ªôt payment SUCCESS
 *  - ƒë√£ c√≥ c√°c ticket g·∫Øn v√†o order qua order_items(kind='TICKET', ref_id=tickets.id)
 * H√†nh ƒë·ªông:
 *  - ph√°t QR cho ticket ch∆∞a c√≥, set tickets.status='ISSUED'
 *  - ƒë·ªïi orders.status='confirmed', confirmed_at=UTC_TIMESTAMP()
 */
router.post('/orders/:id/confirm', async (req, res) => {
  const id = Number(req.params.id);
  if (!Number.isInteger(id) || id <= 0) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');

  const conn = await pool.getConnection();
  try {
    await conn.beginTransaction();

    const [[o]] = await conn.query(
      `SELECT id,status,expires_at FROM orders WHERE id=? FOR UPDATE`, [id]
    );
    if (!o) { await conn.rollback(); return bad(res,'NOT_FOUND','Kh√¥ng t√¨m th·∫•y order',404); }
    if (o.status !== 'pending') { await conn.rollback(); return bad(res,'INVALID_STATE','Ch·ªâ confirm ƒë∆°n pending',409); }
    if (o.expires_at && new Date(o.expires_at) <= new Date()) {
      await conn.rollback(); return bad(res,'ORDER_EXPIRED','ƒê∆°n ƒë√£ h·∫øt h·∫°n',409);
    }

    const [[pOk]] = await conn.query(
      `SELECT COUNT(*) AS ok FROM payments WHERE order_id=? AND status='SUCCESS'`, [id]
    );
    if (!pOk.ok) { await conn.rollback(); return bad(res,'NO_SUCCESS_PAYMENT','Ch∆∞a c√≥ thanh to√°n th√†nh c√¥ng',409); }

    // l·∫•y c√°c ticket thu·ªôc order
    const [tks] = await conn.query(
      `SELECT t.id, t.qr_code, t.status
         FROM order_items oi
         JOIN tickets t ON t.id = oi.ref_id AND oi.kind='TICKET'
        WHERE oi.order_id=? FOR UPDATE`,
      [id]
    );
    if (!tks.length) { await conn.rollback(); return bad(res,'NO_TICKETS','ƒê∆°n ch∆∞a c√≥ v√©',409); }

    // ph√°t QR v√† set ISSUED cho v√© ch∆∞a ph√°t
    for (const t of tks) {
      if (!t.qr_code || t.status !== 'ISSUED') {
        const qr = t.qr_code || `QR:${id}:${t.id}:${Date.now()}`;
        await conn.query(
          `UPDATE tickets SET qr_code=?, status='ISSUED', updated_at=UTC_TIMESTAMP() WHERE id=?`,
          [qr, t.id]
        );
      }
    }

    await conn.query(
      `UPDATE orders SET status='confirmed', confirmed_at=UTC_TIMESTAMP(), updated_at=UTC_TIMESTAMP() WHERE id=?`,
      [id]
    );

    await conn.commit();
    res.json({ id, confirmed: true, tickets: tks.length });
  } catch (e) {
    await conn.rollback();
    return bad(res, 'INTERNAL', e.message, 500);
  } finally { conn.release(); }
});

module.exports = router;

```

### routes\payments.js
```js
// server/routes/payments.js
const express = require('express');
const router = express.Router();
const crypto = require('crypto');
const { pool } = require('../src/db');

function bad(res, code, message, status = 400, extra = {}) {
  return res.status(status).json({ error: code, message, ...extra });
}

/* ========== LIST PAYMENTS ==========
   GET /api/payments?status=&provider=&q=&page=1&pageSize=20
   C·ªôt t·ªìn t·∫°i: id, order_id, provider, ref_code, merchant_txn_ref, amount, currency,
                status, payload, created_at, bank_code, pay_date, client_ip,
                ipn_verified, ipn_at, fail_reason
*/
router.get('/payments', async (req, res) => {
  try {
    const page = Math.max(1, Number(req.query.page || 1));
    const pageSize = Math.min(100, Math.max(1, Number(req.query.pageSize || 20)));
    const status = String(req.query.status || '').trim();
    const provider = String(req.query.provider || '').trim();
    const q = String(req.query.q || '').trim();

    const where = [];
    const args = [];
    if (status) { where.push(`p.status = ?`); args.push(status); }
    if (provider) { where.push(`p.provider = ?`); args.push(provider); }
    if (q) {
      // t√¨m theo order_id, ref_code, merchant_txn_ref, bank_code, client_ip, email, phone
      where.push(`(CAST(p.order_id AS CHAR) LIKE ?
                  OR IFNULL(p.ref_code,'') LIKE ?
                  OR IFNULL(p.merchant_txn_ref,'') LIKE ?
                  OR IFNULL(p.bank_code,'') LIKE ?
                  OR IFNULL(p.client_ip,'') LIKE ?
                  OR IFNULL(u.email,'') LIKE ?
                  OR IFNULL(u.phone,'') LIKE ?)`);
      for (let i = 0; i < 7; i++) args.push(`%${q}%`);
    }
    const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';
    const offset = (page - 1) * pageSize;

    const [rows] = await pool.query(
      `SELECT
         p.id,
         p.order_id            AS orderId,
         p.provider,
         p.status,
         p.amount,
         p.currency,
         p.bank_code           AS bankCode,
         p.pay_date            AS payDate,
         p.created_at          AS createdAt,
         p.merchant_txn_ref    AS txnRef,
         p.ref_code            AS refCode,
         p.client_ip           AS clientIp,
         IFNULL(u.email,'')    AS email,
         IFNULL(u.phone,'')    AS phone
       FROM payments p
       LEFT JOIN orders o ON o.id = p.order_id
       LEFT JOIN users  u ON u.id = o.user_id
       ${whereSql}
       ORDER BY p.id DESC
       LIMIT ? OFFSET ?`,
      [...args, pageSize, offset]
    );

    const [[cnt]] = await pool.query(
      `SELECT COUNT(1) AS total
       FROM payments p
       LEFT JOIN orders o ON o.id = p.order_id
       LEFT JOIN users  u ON u.id = o.user_id
       ${whereSql}`, args
    );

    res.json({ items: rows, total: Number(cnt.total || 0), page, pageSize });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

/* ========== PAYMENT DETAIL ==========
   GET /api/payments/:id
   Tr·∫£ k√®m order c∆° b·∫£n v√† tickets n·∫øu c√≥.
*/
router.get('/payments/:id', async (req, res) => {
  try {
    const id = Number(req.params.id);
    const [[p]] = await pool.query(
      `SELECT
         p.id, p.order_id AS orderId, p.provider, p.status, p.amount, p.currency,
         p.bank_code AS bankCode, p.pay_date AS payDate, p.created_at AS createdAt,
         p.merchant_txn_ref AS merchantTxnRef, p.ref_code AS refCode,
         p.client_ip AS clientIp, p.fail_reason AS failReason
       FROM payments p
       WHERE p.id=?`, [id]
    );
    if (!p) return bad(res, 'NOT_FOUND', 'Payment kh√¥ng t·ªìn t·∫°i', 404);

    const [[o]] = await pool.query(
      `SELECT
         o.id, o.order_code AS orderCode, o.status, o.total, o.created_at AS createdAt,
         u.email, u.phone
       FROM orders o
       LEFT JOIN users u ON u.id = o.user_id
       WHERE o.id=?`, [p.orderId]
    );

    const [tickets] = await pool.query(
      `SELECT t.id, t.qr_code AS qrCode, t.status,
              s.row_label AS rowLabel, s.col_number AS colNumber, s.seat_type AS seatType
       FROM tickets t
       LEFT JOIN seats s ON s.id = t.seat_id
       WHERE t.order_id=?`, [p.orderId]
    );

    res.json({
      payment: p,
      order: {
        id: o?.id || null,
        orderCode: o?.orderCode || null,
        status: o?.status || null,
        total: o?.total || 0,
        createdAt: o?.createdAt || null,
        email: o?.email || '',
        phone: o?.phone || '',
        tickets
      }
    });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

/* ========== VNPay helpers (kh·ªõp .env: VNPAY_*) ========== */
const cfg = {
  vnpUrl:     process.env.VNPAY_URL        || 'https://sandbox.vnpayment.vn/paymentv2/vpcpay.html',
  tmnCode:    process.env.VNPAY_TMN_CODE   || '',
  hashSecret: process.env.VNPAY_HASH_SECRET|| '',
  returnUrl:  process.env.VNPAY_RETURN_URL || 'http://localhost:5173/vnpay-return',
  locale:     process.env.VNPAY_LOCALE     || 'vn',
  currCode:   'VND'
};
function sortObject(o){ return Object.keys(o).sort().reduce((r,k)=>{ r[k]=o[k]; return r; },{}); }
function hmac512(secret, data){ return crypto.createHmac('sha512', secret).update(Buffer.from(data,'utf-8')).digest('hex'); }
function buildVNPayUrl({ amount, ip, orderId }) {
  const txnRef = 'V' + Date.now().toString(36).toUpperCase();
  const d = new Date();
  const ymdHMS = (x)=> x.getUTCFullYear().toString()
    + String(x.getUTCMonth()+1).padStart(2,'0')
    + String(x.getUTCDate()).padStart(2,'0')
    + String(x.getUTCHours()).padStart(2,'0')
    + String(x.getUTCMinutes()).padStart(2,'0')
    + String(x.getUTCSeconds()).padStart(2,'0');
  const params = {
    vnp_Version:'2.1.0', vnp_Command:'pay', vnp_TmnCode:cfg.tmnCode,
    vnp_Amount: Math.round(Number(amount)*100).toString(), vnp_CurrCode: cfg.currCode,
    vnp_TxnRef: txnRef, vnp_OrderInfo: `ORDER_${orderId}`, vnp_OrderType:'other',
    vnp_Locale: cfg.locale, vnp_ReturnUrl: cfg.returnUrl, vnp_IpAddr: ip || '0.0.0.0',
    vnp_CreateDate: ymdHMS(d),
  };
  const ord = sortObject(params);
  const raw = Object.entries(ord).map(([k,v])=>`${k}=${encodeURIComponent(v)}`).join('&');
  const vnp_SecureHash = hmac512(cfg.hashSecret, raw);
  return { payUrl: `${cfg.vnpUrl}?${raw}&vnp_SecureHash=${vnp_SecureHash}`, txnRef };
}
function verifyVNPaySignature(q){
  const x = { ...q };
  const secure = x.vnp_SecureHash || x.vnp_SecureHashType || '';
  delete x.vnp_SecureHash; delete x.vnp_SecureHashType;
  const raw = Object.entries(sortObject(x)).map(([k,v])=>`${k}=${encodeURIComponent(v)}`).join('&');
  return String(secure).toLowerCase() === hmac512(cfg.hashSecret, raw).toLowerCase();
}

/* ========== VNPay: t·∫°o link ==========
   POST /api/payments/vnpay/create { orderId }
*/
router.post('/payments/vnpay/create', async (req, res) => {
  const orderId = Number(req.body?.orderId || 0);
  const ip = String(req.headers['x-forwarded-for'] || req.socket.remoteAddress || '');
  try {
    const [[o]] = await pool.query(`SELECT id,status,total FROM orders WHERE id=?`, [orderId]);
    if (!o) return bad(res, 'NOT_FOUND', 'Order kh√¥ng t·ªìn t·∫°i', 404);
    if (o.status === 'PAID') return bad(res, 'ORDER_PAID', 'Order ƒë√£ thanh to√°n', 409);

    const { payUrl, txnRef } = buildVNPayUrl({ amount: Number(o.total || 0), ip, orderId });
    await pool.query(
      `INSERT INTO payments (order_id, provider, merchant_txn_ref, amount, currency, status, client_ip, created_at)
       VALUES (?, 'VNPAY', ?, ?, 'VND', 'INITIATED', ?, UTC_TIMESTAMP())`,
      [orderId, txnRef, o.total, ip]
    );
    res.json({ payUrl, txnRef });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

/* ========== VNPay return ==========
   GET /api/payments/vnpay/return?... (VNPay redirect)
*/
router.get('/payments/vnpay/return', async (req, res) => {
  const q = req.query || {};
  try {
    if (!verifyVNPaySignature(q)) return bad(res, 'INVALID_SIG', 'Invalid signature', 400);
    const txnRef = String(q.vnp_TxnRef || '');
    const responseCode = String(q.vnp_ResponseCode || '');
    const orderId = Number((q.vnp_OrderInfo || '').replace(/^ORDER_/,'') || 0);
    const bankCode = String(q.vnp_BankCode || '');
    const payDateStr = String(q.vnp_PayDate || ''); // yyyymmddHHMMSS

    const payDate = payDateStr
      ? new Date(Date.UTC(
          Number(payDateStr.slice(0,4)),
          Number(payDateStr.slice(4,6))-1,
          Number(payDateStr.slice(6,8)),
          Number(payDateStr.slice(8,10)),
          Number(payDateStr.slice(10,12)),
          Number(payDateStr.slice(12,14))
        ))
      : null;

    const conn = await pool.getConnection();
    try {
      await conn.beginTransaction();
      const [[p]] = await conn.query(`SELECT * FROM payments WHERE merchant_txn_ref=? FOR UPDATE`, [txnRef]);
      if (!p) { await conn.rollback(); return bad(res, 'PAY_NOT_FOUND', 'Payment kh√¥ng t·ªìn t·∫°i', 404); }

      if (responseCode === '00') {
        await conn.query(
          `UPDATE payments SET status='SUCCESS', bank_code=?, pay_date=? WHERE id=?`,
          [bankCode || null, payDate || null, p.id]
        );
        await conn.query(`UPDATE orders SET status='PAID' WHERE id=?`, [p.order_id || orderId]);
      } else {
        await conn.query(
          `UPDATE payments SET status='FAILED', fail_reason=? WHERE id=?`,
          [responseCode, p.id]
        );
        await conn.query(`UPDATE orders SET status='CANCELLED' WHERE id=?`, [p.order_id || orderId]);
      }
      await conn.commit();
      return res.json({ orderId: p.order_id || orderId, status: responseCode === '00' ? 'PAID' : 'FAILED' });
    } catch (e) {
      try { await conn.rollback(); } catch {}
      return bad(res, 'INTERNAL', e.message, 500);
    } finally {
      conn.release();
    }
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

/* ========== VNPay IPN ==========
   GET /api/payments/vnpay/ipn?... (server-to-server)
*/
router.get('/payments/vnpay/ipn', async (req, res) => {
  const q = req.query || {};
  function done(code, msg){ return res.json({ RspCode: code, Message: msg }); }
  try {
    const valid = verifyVNPaySignature(q);
    const txnRef = String(q.vnp_TxnRef || '');
    const responseCode = String(q.vnp_ResponseCode || '');
    const orderId = Number((q.vnp_OrderInfo || '').replace(/^ORDER_/,'') || 0);
    const bankCode = String(q.vnp_BankCode || '');
    const payDate = null; // VNPay ƒë√£ c√≥ ·ªü "return"; c√≥ th·ªÉ parse nh∆∞ tr√™n n·∫øu c·∫ßn

    const conn = await pool.getConnection();
    try {
      await conn.beginTransaction();
      const [[p]] = await conn.query(`SELECT * FROM payments WHERE merchant_txn_ref=? FOR UPDATE`, [txnRef]);
      if (!p) { await conn.rollback(); return done('01','Order not found'); }

      await conn.query(
        `INSERT INTO payment_ipn_logs (payment_id, query_raw, signature_valid, response_code)
         VALUES (?, ?, ?, ?)`,
        [p.id, JSON.stringify(q), valid ? 1 : 0, responseCode]
      );
      if (!valid) { await conn.commit(); return done('97','Invalid signature'); }

      if (responseCode === '00') {
        await conn.query(
          `UPDATE payments SET status='SUCCESS', bank_code=?, pay_date=IFNULL(pay_date, UTC_TIMESTAMP()), ipn_verified=1, ipn_at=UTC_TIMESTAMP() WHERE id=?`,
          [bankCode || null, p.id]
        );
        await conn.query(`UPDATE orders SET status='PAID' WHERE id=?`, [p.order_id || orderId]);
        await conn.commit();
        return done('00','Confirm Success');
      } else {
        await conn.query(
          `UPDATE payments SET status='FAILED', fail_reason=?, ipn_verified=1, ipn_at=UTC_TIMESTAMP() WHERE id=?`,
          [responseCode, p.id]
        );
        await conn.query(`UPDATE orders SET status='CANCELLED' WHERE id=?`, [p.order_id || orderId]);
        await conn.commit();
        return done('24','Failed');
      }
    } catch (e) {
      try { await conn.rollback(); } catch {}
      return done('99', 'Unknown error');
    } finally {
      conn.release();
    }
  } catch (e) {
    return done('99','Unknown error');
  }
});

module.exports = router;

```

### routes\refunds.js
```js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

function bad(res, code, message, status = 400, extra = {}) {
  return res.status(status).json({ error: code, message, ...extra });
}

const REFUND_WINDOW_HOURS = Number(process.env.REFUND_WINDOW_HOURS || 2);

router.post('/refunds', async (req, res) => {
  const orderId = Number(req.body?.orderId);
  const reason = String(req.body?.reason || 'user_request');
  if (!orderId) return bad(res, 'BAD_REQUEST', 'orderId l√† b·∫Øt bu·ªôc');

  const conn = await pool.getConnection();
  try {
    await conn.beginTransaction();

    const [[o]] = await conn.query(
      `SELECT id, status, total FROM orders WHERE id = ? FOR UPDATE`,
      [orderId]
    );
    if (!o) { await conn.rollback(); return bad(res, 'NOT_FOUND', 'Order kh√¥ng t·ªìn t·∫°i', 404); }
    if (o.status !== 'PAID') { await conn.rollback(); return bad(res, 'ORDER_STATE', `Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá: ${o.status}`, 409); }

    const [tks] = await conn.query(
      `SELECT id, seat_id AS seatId, showtime_id AS showtimeId, status
         FROM tickets WHERE order_id = ? FOR UPDATE`,
      [orderId]
    );
    if (tks.length === 0) { await conn.rollback(); return bad(res, 'NO_TICKETS', 'Order kh√¥ng c√≥ v√©'); }

    const scanned = tks.filter(t => t.status === 'SCANNED').map(t => Number(t.seatId));
    if (scanned.length) { await conn.rollback(); return bad(res, 'TICKET_SCANNED', 'C√≥ v√© ƒë√£ qu√©t', 409, { seatIds: scanned }); }

    const showIds = [...new Set(tks.map(t => Number(t.showtimeId)))];
    const [stTimes] = await conn.query(
      `SELECT id, start_at, TIMESTAMPDIFF(MINUTE, UTC_TIMESTAMP(), start_at) AS min_left
         FROM showtimes WHERE id IN (?)`,
      [showIds]
    );
    const minLeft = Math.min(...stTimes.map(r => Number(r.min_left)));
    if (minLeft <= REFUND_WINDOW_HOURS * 60) {
      await conn.rollback();
      return bad(res, 'WINDOW_CLOSED', 'H·∫øt h·∫°n ho√†n ti·ªÅn (< REFUND_WINDOW_HOURS)', 409, { minutesLeft: minLeft });
    }

    const idsToRefund = tks.filter(t => t.status === 'ISSUED').map(t => Number(t.id));
    if (idsToRefund.length) {
      await conn.query(
        `UPDATE tickets SET status = 'REFUNDED' WHERE id IN (?)`,
        [idsToRefund]
      );
    }

    await conn.query(
      `UPDATE orders SET status = 'REFUNDED' WHERE id = ?`,
      [orderId]
    );

    await conn.query(
      `UPDATE payments
         SET status = 'REFUNDED', ipn_at = UTC_TIMESTAMP()
       WHERE order_id = ? AND status = 'SUCCESS'`,
      [orderId]
    );

    await conn.commit();
    return res.json({
      orderId,
      status: 'REFUNDED',
      refundedTickets: tks.filter(t => t.status === 'ISSUED').map(t => ({ id: Number(t.id), seatId: Number(t.seatId) })),
      refundAmount: Number(o.total || 0),
      currency: 'VND',
      reason
    });
  } catch (e) {
    try { await conn.rollback(); } catch {}
    return bad(res, 'INTERNAL', e.message, 500);
  } finally {
    conn.release();
  }
});

module.exports = router;

```

### routes\reports.js
```js
// server/routes/reports.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

const isISO = s => typeof s === 'string' && !Number.isNaN(Date.parse(s));
const bad = (res, m) => res.status(400).json({ error: 'BAD_REQUEST', message: m });
const isoToMy = (iso) => {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return null;
  const P = n => String(n).padStart(2, '0');
  return `${d.getUTCFullYear()}-${P(d.getUTCMonth()+1)}-${P(d.getUTCDate())} ${P(d.getUTCHours())}:${P(d.getUTCMinutes())}:${P(d.getUTCSeconds())}`;
};

// Ping ƒë·ªÉ ki·ªÉm tra ƒë√£ mount
router.get('/reports/ping', (_req, res) => res.json({ ok: true }));

// SUMMARY
router.get('/reports/summary', async (req, res) => {
  const { from, to } = req.query;
  if (!isISO(from) || !isISO(to)) return bad(res, 'from/to required ISO8601');
  const F = isoToMy(from), T = isoToMy(to);
  try {
    const [[{ gross=0 }]] = await pool.query(
      `SELECT COALESCE(SUM(amount),0) gross
         FROM payments WHERE status='SUCCESS'
           AND COALESCE(pay_date, created_at) BETWEEN ? AND ?`, [F, T]);
    const [[{ refunded=0 }]] = await pool.query(
      `SELECT COALESCE(SUM(amount),0) refunded
         FROM payments WHERE status='REFUNDED'
           AND COALESCE(ipn_at, created_at) BETWEEN ? AND ?`, [F, T]);
    const [[{ sold=0 }]] = await pool.query(
      `SELECT COUNT(*) sold FROM tickets
        WHERE status IN ('ISSUED','SCANNED') AND created_at BETWEEN ? AND ?`, [F, T]);
    const [[{ cnt=0 }]] = await pool.query(
      `SELECT COUNT(*) cnt FROM orders
        WHERE status='PAID' AND created_at BETWEEN ? AND ?`, [F, T]);
    res.json({
      from, to,
      gross_revenue: Number(gross),
      refund_total: Number(refunded),
      net_revenue: Number(gross) - Number(refunded),
      tickets_sold: Number(sold),
      orders_count: Number(cnt)
    });
  } catch (e) { res.status(500).json({ error:'INTERNAL', message:e.message }); }
});

// DAILY
router.get('/reports/daily', async (req, res) => {
  const { from, to } = req.query;
  if (!isISO(from) || !isISO(to)) return bad(res, 'from/to required ISO8601');
  const F = isoToMy(from), T = isoToMy(to);
  try {
    const [pSuc] = await pool.query(
      `SELECT DATE(COALESCE(pay_date, created_at)) d, SUM(amount) v
         FROM payments WHERE status='SUCCESS'
           AND COALESCE(pay_date, created_at) BETWEEN ? AND ?
        GROUP BY DATE(COALESCE(pay_date, created_at))`, [F, T]);
    const [pRef] = await pool.query(
      `SELECT DATE(COALESCE(ipn_at, created_at)) d, SUM(amount) v
         FROM payments WHERE status='REFUNDED'
           AND COALESCE(ipn_at, created_at) BETWEEN ? AND ?
        GROUP BY DATE(COALESCE(ipn_at, created_at))`, [F, T]);
    const [tDay] = await pool.query(
      `SELECT DATE(created_at) d, COUNT(*) v
         FROM tickets WHERE status IN ('ISSUED','SCANNED')
           AND created_at BETWEEN ? AND ?
        GROUP BY DATE(created_at)`, [F, T]);
    const [oDay] = await pool.query(
      `SELECT DATE(created_at) d, COUNT(*) v
         FROM orders WHERE status='PAID'
           AND created_at BETWEEN ? AND ?
        GROUP BY DATE(created_at)`, [F, T]);

    const map = new Map();
    const add = (rows, key) => rows.forEach(r => {
      const d = r.d instanceof Date ? r.d.toISOString().slice(0,10) : String(r.d);
      const o = map.get(d) || { date:d, gross:0, refund:0, net:0, tickets:0, orders:0 };
      o[key] = Number(r.v||0); map.set(d, o);
    });
    add(pSuc,'gross'); add(pRef,'refund'); add(tDay,'tickets'); add(oDay,'orders');
    res.json([...map.values()].map(o => ({ ...o, net:o.gross-o.refund }))
      .sort((a,b)=>a.date.localeCompare(b.date)));
  } catch (e) { res.status(500).json({ error:'INTERNAL', message:e.message }); }
});

// OCCUPANCY
router.get('/reports/occupancy', async (req, res) => {
  const { date } = req.query;
  if (!/^\d{4}-\d{2}-\d{2}$/.test(String(date||''))) return bad(res,'date required YYYY-MM-DD');
  const F = `${date} 00:00:00`, T = `${date} 23:59:59`;
  try {
    const [rows] = await pool.query(
      `SELECT sh.id showtime_id, m.title movie_title, sh.start_at,
              r.capacity, COALESCE(COUNT(t.id),0) sold,
              CASE WHEN r.capacity=0 THEN 0 ELSE COALESCE(COUNT(t.id),0)/r.capacity END occ
         FROM showtimes sh
         JOIN movies m ON m.id=sh.movie_id
         JOIN rooms r  ON r.id=sh.room_id
    LEFT JOIN tickets t ON t.showtime_id=sh.id AND t.status IN ('ISSUED','SCANNED')
        WHERE sh.start_at BETWEEN ? AND ?
        GROUP BY sh.id, m.title, sh.start_at, r.capacity
        ORDER BY sh.start_at`, [F, T]);
    res.json(rows.map(r => ({
      showtime_id:Number(r.showtime_id),
      movie_title:r.movie_title,
      starts_at:new Date(r.start_at).toISOString(),
      sold:Number(r.sold||0),
      capacity:Number(r.capacity||0),
      occupancy:Number(r.occ||0)
    })));
  } catch (e) { res.status(500).json({ error:'INTERNAL', message:e.message }); }
});

// TOP MOVIES
router.get('/reports/top-movies', async (req, res) => {
  const { from, to } = req.query;
  if (!isISO(from) || !isISO(to)) return bad(res, 'from/to required ISO8601');
  const F = isoToMy(from), T = isoToMy(to);
  const limit = Math.max(1, Math.min(100, parseInt(req.query.limit || '10', 10)));
  try {
    const [rows] = await pool.query(
      `SELECT m.id movie_id, m.title, COUNT(t.id) tickets_sold
         FROM tickets t
         JOIN showtimes s ON s.id=t.showtime_id
         JOIN movies m ON m.id=s.movie_id
        WHERE t.status IN ('ISSUED','SCANNED') AND t.created_at BETWEEN ? AND ?
        GROUP BY m.id, m.title
        ORDER BY tickets_sold DESC, m.title ASC
        LIMIT ?`, [F, T, limit]);
    res.json(rows.map(r => ({
      movie_id:Number(r.movie_id), title:r.title, tickets_sold:Number(r.tickets_sold||0)
    })));
  } catch (e) { res.status(500).json({ error:'INTERNAL', message:e.message }); }
});

module.exports = router;

```

### routes\rooms.js
```js
// server/routes/rooms.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

const bad = (res, code, message, status = 400, extra = {}) =>
  res.status(status).json({ error: code, message, ...extra });

const FT = new Set(['2D','3D','IMAX','4DX']);

async function branchExists(id){ const [[r]] = await pool.query(`SELECT id FROM branches WHERE id=?`, [id]); return !!r; }
async function roomById(id){
  const [[r]] = await pool.query(`SELECT id,branch_id,name,format_type,capacity,is_active FROM rooms WHERE id=?`, [id]);
  return r || null;
}

// LIST
router.get('/rooms', async (req,res)=>{
  const branchId = req.query.branchId ? Number(req.query.branchId) : null;
  const page = Math.max(1, Number(req.query.page || 1));
  const pageSize = Math.min(100, Math.max(1, Number(req.query.pageSize || 50)));
  const where=[], args=[];
  if (branchId){ where.push('r.branch_id=?'); args.push(branchId); }
  const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';
  const [[{ total }]] = await pool.query(`SELECT COUNT(*) total FROM rooms r ${whereSql}`, args);
  const [rows] = await pool.query(
    `SELECT r.id,r.branch_id,r.name,r.format_type,r.capacity,r.is_active
     FROM rooms r ${whereSql} ORDER BY r.id DESC LIMIT ? OFFSET ?`,
    [...args, pageSize, (page-1)*pageSize]
  );
  res.json({ page,pageSize,total, items: rows.map(r=>({
    id:Number(r.id), branchId:Number(r.branch_id), name:r.name,
    formatType:r.format_type, capacity:Number(r.capacity||0), isActive:!!r.is_active
  })) });
});

// DETAIL
router.get('/rooms/:id', async (req,res)=>{
  const id = Number(req.params.id); if(!id) return bad(res,'BAD_REQUEST','id kh√¥ng h·ª£p l·ªá');
  const r = await roomById(id); if(!r) return bad(res,'NOT_FOUND','Kh√¥ng c√≥ ph√≤ng',404);
  res.json({ id:Number(r.id), branchId:Number(r.branch_id), name:r.name,
    formatType:r.format_type, capacity:Number(r.capacity||0), isActive:!!r.is_active });
});

// CREATE: capacity kh√¥ng b·∫Øt bu·ªôc, m·∫∑c ƒë·ªãnh 0. S·∫Ω c·∫≠p nh·∫≠t theo s∆° ƒë·ªì gh·∫ø.
router.post('/rooms', async (req,res)=>{
  const b = req.body||{};
  const branchId = Number(b.branchId||0);
  const name = String(b.name||'').trim();
  const formatType = String(b.formatType||'').toUpperCase();
  const capacity = Number.isFinite(b.capacity) ? Math.max(0, Number(b.capacity||0)) : 0;
  const isActive = b.isActive===false ? 0 : 1;

  if(!branchId||!name) return bad(res,'BAD_REQUEST','branchId, name b·∫Øt bu·ªôc');
  if(!FT.has(formatType)) return bad(res,'BAD_REQUEST','formatType kh√¥ng h·ª£p l·ªá');
  if(!(await branchExists(branchId))) return bad(res,'BRANCH_NOT_FOUND','branchId kh√¥ng t·ªìn t·∫°i');

  const [r] = await pool.query(
    `INSERT INTO rooms (branch_id,name,format_type,capacity,is_active,created_at,updated_at)
     VALUES (?,?,?,?,?,UTC_TIMESTAMP(),UTC_TIMESTAMP())`,
    [branchId,name,formatType,capacity,isActive]
  );
  res.json({ id:Number(r.insertId), branchId, name, formatType, capacity, isActive:!!isActive });
});

// UPDATE: kh√¥ng cho s·ª≠a capacity tr·ª±c ti·∫øp qua UI, nh∆∞ng API v·∫´n h·ªó tr·ª£ n·∫øu c·∫ßn.
router.patch('/rooms/:id', async (req,res)=>{
  const id = Number(req.params.id); if(!id) return bad(res,'BAD_REQUEST','id kh√¥ng h·ª£p l·ªá');
  if(!(await roomById(id))) return bad(res,'NOT_FOUND','Kh√¥ng c√≥ ph√≤ng',404);
  const b=req.body||{}; const sets=[],args=[];
  if(b.branchId!==undefined){ const bid=Number(b.branchId||0);
    if(!bid) return bad(res,'BAD_REQUEST','branchId kh√¥ng h·ª£p l·ªá');
    if(!(await branchExists(bid))) return bad(res,'BRANCH_NOT_FOUND','branchId kh√¥ng t·ªìn t·∫°i');
    sets.push('branch_id=?'); args.push(bid);
  }
  if(b.name!==undefined){ const nm=String(b.name||'').trim(); if(!nm) return bad(res,'BAD_REQUEST','name kh√¥ng h·ª£p l·ªá'); sets.push('name=?'); args.push(nm); }
  if(b.formatType!==undefined){ const ft=String(b.formatType||'').toUpperCase(); if(!FT.has(ft)) return bad(res,'BAD_REQUEST','formatType kh√¥ng h·ª£p l·ªá'); sets.push('format_type=?'); args.push(ft); }
  if(b.capacity!==undefined){ const cap=Math.max(0,Number(b.capacity||0)); sets.push('capacity=?'); args.push(cap); }
  if(b.isActive!==undefined){ sets.push('is_active=?'); args.push(b.isActive?1:0); }
  if(!sets.length) return bad(res,'BAD_REQUEST','Kh√¥ng c√≥ thay ƒë·ªïi');
  sets.push('updated_at=UTC_TIMESTAMP()'); args.push(id);
  await pool.query(`UPDATE rooms SET ${sets.join(', ')} WHERE id=?`, args);
  const r=await roomById(id);
  res.json({ id:Number(r.id), branchId:Number(r.branch_id), name:r.name,
    formatType:r.format_type, capacity:Number(r.capacity||0), isActive:!!r.is_active });
});

// ƒê·ªìng b·ªô capacity t·ª´ b·∫£ng seats
router.post('/rooms/:roomId/recalc-capacity', async (req,res)=>{
  const roomId = Number(req.params.roomId);
  if (!Number.isInteger(roomId) || roomId <= 0)
    return bad(res,'BAD_REQUEST','roomId kh√¥ng h·ª£p l·ªá');

  const [[room]] = await pool.query('SELECT id FROM rooms WHERE id=?', [roomId]);
  if (!room) return bad(res,'NOT_FOUND','Kh√¥ng t√¨m th·∫•y ph√≤ng',404);

  const [[c]] = await pool.query('SELECT COUNT(*) AS n FROM seats WHERE room_id=?', [roomId]);
  await pool.query('UPDATE rooms SET capacity=?, updated_at=UTC_TIMESTAMP() WHERE id=?', [c.n, roomId]);
  res.json({ roomId, capacity: Number(c.n), recalculated: true });
});

// DELETE (ch·∫∑n n·∫øu c√≤n showtimes)
router.delete('/rooms/:id', async (req,res)=>{
  const id = Number(req.params.id); if(!id) return bad(res,'BAD_REQUEST','id kh√¥ng h·ª£p l·ªá');
  if(!(await roomById(id))) return bad(res,'NOT_FOUND','Kh√¥ng c√≥ ph√≤ng',404);
  const [[{ cnt }]] = await pool.query(`SELECT COUNT(*) cnt FROM showtimes WHERE room_id=?`, [id]);
  if(Number(cnt)>0) return bad(res,'ROOM_HAS_SHOWTIMES','Kh√¥ng th·ªÉ xo√° v√¨ c√≤n su·∫•t chi·∫øu',409);
  const conn=await pool.getConnection();
  try{ await conn.beginTransaction();
    await conn.query(`DELETE FROM seats WHERE room_id=?`, [id]);
    await conn.query(`DELETE FROM rooms WHERE id=?`, [id]);
    await conn.commit(); res.json({ ok:true });
  } catch(e){ await conn.rollback(); bad(res,'SERVER_ERROR',e.message,500); }
  finally{ conn.release(); }
});

module.exports = router;

```

### routes\seats.js
```js
// server/routes/seats.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

function bad(res, code, message, status = 400, extra = {}) {
  return res.status(status).json({ error: code, message, ...extra }); // fix .extra
}

// NOTE: GET /api/rooms/:id/seats ƒë√£ c√≥ trong catalog.js, gi·ªØ nguy√™n.
// Th√™m API l∆∞u layout to√†n b·ªô ph√≤ng.
router.put('/rooms/:roomId/seats/layout', async (req, res) => {
  const roomId = Number(req.params.roomId);
  if (!Number.isInteger(roomId) || roomId <= 0) return bad(res, 'BAD_REQUEST', 'roomId kh√¥ng h·ª£p l·ªá');

  const seats = Array.isArray(req.body?.seats) ? req.body.seats : [];
  // l·ªçc d·ªØ li·ªáu h·ª£p l·ªá: OFF kh√¥ng g·ª≠i l√™n BE
  const clean = [];
  for (const s of seats) {
    const rl = String(s.rowLabel || '').trim().toUpperCase();
    const cn = Number(s.colNumber);
    const tp = String(s.seatType || '').toUpperCase();
    if (!rl || !Number.isInteger(cn) || cn <= 0) continue;
    if (!['STANDARD','VIP','DOUBLE'].includes(tp)) continue;
    clean.push([roomId, rl, cn, tp]);
  }
  if (clean.length === 0) return bad(res, 'BAD_REQUEST', 'Danh s√°ch gh·∫ø tr·ªëng');

  // ph√≤ng t·ªìn t·∫°i?
  const [[room]] = await pool.query('SELECT id FROM rooms WHERE id=?', [roomId]);
  if (!room) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y ph√≤ng', 404);

  const conn = await pool.getConnection();
  try {
    await conn.beginTransaction();
    await conn.query('DELETE FROM seats WHERE room_id=?', [roomId]);

    // bulk insert
    const values = clean.map(() => '(?,?,?,?,0,UTC_TIMESTAMP(),UTC_TIMESTAMP())').join(',');
    const params = [];
    for (const [rid, rl, cn, tp] of clean) params.push(rid, rl, cn, tp);

    await conn.query(
      `INSERT INTO seats(room_id,row_label,col_number,seat_type,is_accessible,created_at,updated_at)
       VALUES ${values}`, params
    );

    await conn.commit();
    res.json({ roomId, inserted: clean.length, replaced: true });
  } catch (e) {
    await conn.rollback();
    return bad(res, 'INTERNAL', e.message, 500);
  } finally {
    conn.release();
  }
});

module.exports = router;

```

### routes\showtimes.js
```js
// server/routes/showtimes.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

// ---------- time helpers ----------
const isMySQL = s => typeof s === 'string' && /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(s);
const isoToMySQL = s => {
  if (!s) return '';
  const d = s.includes('T') ? new Date(s) : new Date(s.replace(' ', 'T') + 'Z');
  if (Number.isNaN(d.getTime())) return '';
  return d.toISOString().slice(0, 19).replace('T', ' ');
};

// ---------- core query builders ----------
function buildWhere({ movieId, roomId, from, to }) {
  const where = [];
  const args = [];
  if (movieId) { where.push('st.movie_id = ?'); args.push(Number(movieId)); }
  if (roomId)  { where.push('st.room_id  = ?'); args.push(Number(roomId)); }
  if (from)    { where.push('st.start_at >= ?'); args.push(isMySQL(from) ? from : isoToMySQL(from)); }
  if (to) {
    where.push('st.start_at < DATE_ADD(?, INTERVAL 1 SECOND)');
    args.push(isMySQL(to) ? to : isoToMySQL(to));
  }
  return { whereSql: where.length ? 'WHERE ' + where.join(' AND ') : '', args };
}

const SELECT_BASE = `
  SELECT
    st.id, st.movie_id, st.room_id,
    m.title,
    r.name AS room_name,
    DATE_FORMAT(st.start_at, '%Y-%m-%d %H:%i:%s') AS start_at,
    DATE_FORMAT(st.end_at,   '%Y-%m-%d %H:%i:%s') AS end_at,
    st.base_price
  FROM showtimes st
  JOIN movies m ON m.id = st.movie_id
  JOIN rooms  r ON r.id = st.room_id
`;

// ===== LIST =====
router.get('/showtimes', async (req, res) => {
  try {
    const { whereSql, args } = buildWhere(req.query || {});
    const [rows] = await pool.query(`${SELECT_BASE} ${whereSql} ORDER BY st.start_at ASC`, args);
    res.json({ items: rows });
  } catch (e) { res.status(500).json({ error: 'INTERNAL', message: e.message }); }
});

// Alias: /api/movies/:id/showtimes?from=&to=
router.get('/movies/:id/showtimes', async (req, res) => {
  try {
    const q = { ...(req.query || {}), movieId: req.params.id };
    const { whereSql, args } = buildWhere(q);
    const [rows] = await pool.query(`${SELECT_BASE} ${whereSql} ORDER BY st.start_at ASC`, args);
    res.json({ items: rows });
  } catch (e) { res.status(500).json({ error: 'INTERNAL', message: e.message }); }
});

// ===== R·∫†P ƒëang chi·∫øu phim trong kho·∫£ng th·ªùi gian =====
router.get('/movies/:id/exhibitors', async (req, res) => {
  const movieId = Number(req.params.id || 0);
  if (!movieId) return res.status(400).json({ error: 'BAD_REQUEST', message: 'movieId kh√¥ng h·ª£p l·ªá' });
  const from = req.query.from ? (isMySQL(req.query.from) ? req.query.from : isoToMySQL(req.query.from)) : null;
  const to   = req.query.to   ? (isMySQL(req.query.to)   ? req.query.to   : isoToMySQL(req.query.to))   : null;

  const where = ['st.movie_id = ?'];
  const args = [movieId];
  if (from) { where.push('st.start_at >= ?'); args.push(from); }
  if (to)   { where.push('st.start_at < DATE_ADD(?, INTERVAL 1 SECOND)'); args.push(to); }

  const sql = `
    SELECT e.id AS exhibitorId, e.name AS exhibitorName,
           b.id AS branchId, b.name AS branchName, b.city,
           COUNT(st.id) AS showtimes
    FROM showtimes st
    JOIN rooms r      ON r.id = st.room_id
    JOIN branches b   ON b.id = r.branch_id
    JOIN exhibitors e ON e.id = b.exhibitor_id
    WHERE ${where.join(' AND ')}
    GROUP BY e.id, e.name, b.id, b.name, b.city
    HAVING showtimes > 0
    ORDER BY e.name, b.name`;
  try {
    const [rows] = await pool.query(sql, args);
    res.json({ items: rows });
  } catch (e) { res.status(500).json({ error: 'INTERNAL', message: e.message }); }
});

// ===== DETAIL =====
router.get('/showtimes/:id', async (req, res) => {
  const id = Number(req.params.id || 0);
  if (!id) return res.status(400).json({ error: 'BAD_REQUEST', message: 'id kh√¥ng h·ª£p l·ªá' });
  try {
    const [rows] = await pool.query(`${SELECT_BASE} WHERE st.id=?`, [id]);
    if (!rows.length) return res.status(404).json({ error: 'NOT_FOUND', message: 'Kh√¥ng c√≥ su·∫•t chi·∫øu' });
    res.json(rows[0]);
  } catch (e) { res.status(500).json({ error: 'INTERNAL', message: e.message }); }
});

// ===== AVAILABILITY =====
router.get('/showtimes/:id/availability', async (req, res) => {
  const stId = Number(req.params.id || 0);
  if (!stId) return res.status(400).json({ error: 'BAD_REQUEST', message: 'id kh√¥ng h·ª£p l·ªá' });
  try {
    const [rows] = await pool.query(
      `
      SELECT s.id AS seat_id, s.row_label, s.col_number,
             CASE WHEN EXISTS (
               SELECT 1
               FROM tickets t
               JOIN order_items oi ON oi.ref_id = t.id AND oi.kind='TICKET'
               JOIN orders o ON o.id = oi.order_id
               WHERE t.showtime_id = ?
                 AND t.seat_id = s.id
                 AND (
                      o.status = 'confirmed'
                   OR (o.status = 'pending' AND (o.expires_at IS NULL OR UTC_TIMESTAMP() < o.expires_at))
                 )
             ) THEN 0 ELSE 1 END AS available
      FROM seats s
      JOIN rooms r   ON r.id = s.room_id
      JOIN showtimes st ON st.room_id = r.id
      WHERE st.id = ?
      ORDER BY s.row_label, s.col_number
      `,
      [stId, stId]
    );
    res.json({ items: rows });
  } catch (e) { res.status(500).json({ error: 'INTERNAL', message: e.message }); }
});

// ===== CREATE =====
router.post('/showtimes', async (req, res) => {
  const movieId = Number(req.body?.movieId);
  const roomId = Number(req.body?.roomId);
  const startAtRaw = String(req.body?.startAt || '').trim();
  const startAt = isMySQL(startAtRaw) ? startAtRaw : isoToMySQL(startAtRaw);
  const basePrice = Number(req.body?.basePrice || 90000);

  if (!movieId || !roomId || !startAt) {
    return res.status(400).json({ error: 'BAD_REQUEST', message: 'movieId, roomId, startAt b·∫Øt bu·ªôc' });
  }

  try {
    const [[m]] = await pool.query(`SELECT duration_min FROM movies WHERE id=?`, [movieId]);
    if (!m) return res.status(404).json({ error: 'NOT_FOUND', message: 'Phim kh√¥ng t·ªìn t·∫°i' });

    const [[{ endAt }]] = await pool.query(
      `SELECT DATE_ADD(?, INTERVAL ? MINUTE) AS endAt`, [startAt, Number(m.duration_min || 0)]
    );

    const [r] = await pool.query(
      `INSERT INTO showtimes (movie_id, room_id, start_at, end_at, base_price, created_at)
       VALUES (?, ?, ?, ?, ?, UTC_TIMESTAMP())`,
      [movieId, roomId, startAt, endAt, basePrice]
    );

    res.json({ id: r.insertId, movieId, roomId, startAt, endAt, basePrice });
  } catch (e) { res.status(500).json({ error: 'INTERNAL', message: e.message }); }
});

// ===== UPDATE =====
router.put('/showtimes/:id', async (req, res) => {
  const id = Number(req.params.id || 0);
  const movieId = Number(req.body?.movieId);
  const roomId = Number(req.body?.roomId);
  const startAtRaw = String(req.body?.startAt || '').trim();
  const startAt = isMySQL(startAtRaw) ? startAtRaw : isoToMySQL(startAtRaw);
  const basePrice = Number(req.body?.basePrice || 90000);

  if (!id || !movieId || !roomId || !startAt) {
    return res.status(400).json({ error: 'BAD_REQUEST', message: 'Thi·∫øu d·ªØ li·ªáu h·ª£p l·ªá' });
  }

  try {
    const [[m]] = await pool.query(`SELECT duration_min FROM movies WHERE id=?`, [movieId]);
    if (!m) return res.status(404).json({ error: 'NOT_FOUND', message: 'Phim kh√¥ng t·ªìn t·∫°i' });

    const [[{ endAt }]] = await pool.query(
      `SELECT DATE_ADD(?, INTERVAL ? MINUTE) AS endAt`, [startAt, Number(m.duration_min || 0)]
    );

    await pool.query(
      `UPDATE showtimes
         SET movie_id=?, room_id=?, start_at=?, end_at=?, base_price=?
       WHERE id=?`,
      [movieId, roomId, startAt, endAt, basePrice, id]
    );

    res.json({ updated: true, startAt, endAt, basePrice });
  } catch (e) { res.status(500).json({ error: 'INTERNAL', message: e.message }); }
});

// ===== DELETE =====
router.delete('/showtimes/:id', async (req, res) => {
  const id = Number(req.params.id || 0);
  if (!id) return res.status(400).json({ error: 'BAD_REQUEST', message: 'id kh√¥ng h·ª£p l·ªá' });
  try {
    const [r] = await pool.query(`DELETE FROM showtimes WHERE id=?`, [id]);
    if (r.affectedRows === 0) return res.status(404).json({ error: 'NOT_FOUND', message: 'Kh√¥ng t√¨m th·∫•y su·∫•t chi·∫øu' });
    res.json({ deleted: true });
  } catch (e) { res.status(500).json({ error: 'INTERNAL', message: e.message }); }
});

module.exports = router;

```

### routes\tickets.js
```js
// server/routes/tickets.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

function bad(res, code, message, status = 400, extra = {}) {
  return res.status(status).json({ error: code, message, ...extra });
}

// ========== LIST: GET /api/tickets ==========
router.get('/tickets', async (req, res) => {
  const page = Math.max(1, Number(req.query.page) || 1);
  const pageSize = Math.min(200, Math.max(1, Number(req.query.pageSize) || 20));
  const status = String(req.query.status || '').toUpperCase();
  const q = String(req.query.q || '').trim();
  const dateFrom = String(req.query.dateFrom || '').trim(); // YYYY-MM-DD
  const dateTo = String(req.query.dateTo || '').trim();     // YYYY-MM-DD

  const where = [];
  const args = [];

  if (status && ['ISSUED','SCANNED'].includes(status)) {
    where.push('tk.status = ?'); args.push(status);
  }
  if (q) {
    where.push(`(
      tk.qr_code LIKE ? OR o.order_code LIKE ? OR COALESCE(u.email,'') LIKE ?
      OR COALESCE(u.phone,'') LIKE ? OR CONCAT(s.row_label, s.col_number) LIKE ?
      OR m.title LIKE ? OR r.name LIKE ? OR b.name LIKE ? OR b.city LIKE ?
    )`);
    for (let i=0;i<9;i++) args.push('%'+q+'%');
  }
  if (dateFrom && dateTo) {
    where.push('DATE(st.start_at) BETWEEN ? AND ?'); args.push(dateFrom, dateTo);
  } else if (dateFrom) {
    where.push('DATE(st.start_at) >= ?'); args.push(dateFrom);
  } else if (dateTo) {
    where.push('DATE(st.start_at) <= ?'); args.push(dateTo);
  }
  const whereSql = where.length ? 'WHERE ' + where.join(' AND ') : '';

  try {
    const [[{ total }]] = await pool.query(
      `SELECT COUNT(*) AS total
       FROM tickets tk
       JOIN orders o ON o.id = tk.order_id
       LEFT JOIN users u ON u.id = o.user_id
       JOIN seats s ON s.id = tk.seat_id
       JOIN showtimes st ON st.id = tk.showtime_id
       JOIN rooms r ON r.id = st.room_id
       JOIN branches b ON b.id = r.branch_id
       JOIN movies m ON m.id = st.movie_id
       ${whereSql}`,
      args
    );

    const [rows] = await pool.query(
      `SELECT tk.id, tk.order_id AS orderId, o.order_code AS orderCode,
              tk.qr_code AS qrCode, tk.status, tk.scanned_at AS scannedAt,
              tk.showtime_id AS showtimeId,
              s.row_label AS rowLabel, s.col_number AS colNumber, s.seat_type AS seatType,
              st.start_at AS startAt,
              m.title AS movieTitle, r.name AS roomName,
              b.name AS branchName, b.city,
              COALESCE(u.email,'') AS email, COALESCE(u.phone,'') AS phone
       FROM tickets tk
       JOIN orders o ON o.id = tk.order_id
       LEFT JOIN users u ON u.id = o.user_id
       JOIN seats s ON s.id = tk.seat_id
       JOIN showtimes st ON st.id = tk.showtime_id
       JOIN rooms r ON r.id = st.room_id
       JOIN branches b ON b.id = r.branch_id
       JOIN movies m ON m.id = st.movie_id
       ${whereSql}
       ORDER BY tk.id DESC
       LIMIT ? OFFSET ?`,
      [...args, pageSize, (page-1)*pageSize]
    );

    res.json({
      items: rows.map(x => ({
        id: x.id,
        orderId: x.orderId,
        orderCode: x.orderCode,
        qrCode: x.qrCode,
        status: x.status,
        scannedAt: x.scannedAt ? new Date(x.scannedAt).toISOString() : null,
        showtimeId: x.showtimeId,
        seat: { row: x.rowLabel, col: x.colNumber, type: x.seatType },
        startAt: x.startAt,
        movieTitle: x.movieTitle,
        roomName: x.roomName,
        branchName: x.branchName,
        city: x.city,
        email: x.email,
        phone: x.phone
      })),
      total, page, pageSize
    });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// ========== ORDER: GET /api/tickets/order/:orderId ==========
router.get('/tickets/order/:orderId', async (req, res) => {
  const orderId = Number(req.params.orderId);
  if (!orderId) return bad(res, 'BAD_REQUEST', 'orderId kh√¥ng h·ª£p l·ªá');
  try {
    const [rows] = await pool.query(
      `SELECT tk.id, tk.order_id, tk.showtime_id, tk.seat_id, tk.qr_code, tk.status, tk.scanned_at,
              s.row_label, s.col_number, s.seat_type
         FROM tickets tk
         JOIN seats s ON s.id = tk.seat_id
        WHERE tk.order_id = ?
        ORDER BY tk.id`, [orderId]
    );

    let showtime = null;
    if (rows.length) {
      const stId = rows[0].showtime_id;
      const [[st]] = await pool.query(
        `SELECT st.id, st.start_at AS startAt, st.end_at AS endAt, st.base_price AS basePrice,
                m.title AS movieTitle, r.name AS roomName, b.name AS branchName, b.city
           FROM showtimes st
           JOIN movies m ON m.id = st.movie_id
           JOIN rooms r ON r.id = st.room_id
           JOIN branches b ON b.id = r.branch_id
          WHERE st.id = ?`, [stId]
      );
      showtime = st || null;
    }

    return res.json({
      orderId,
      showtime,
      items: rows.map(t => ({
        id: Number(t.id),
        showtimeId: Number(t.showtime_id),
        seatId: Number(t.seat_id),
        qrCode: t.qr_code,
        status: t.status,
        scannedAt: t.scanned_at ? new Date(t.scanned_at).toISOString() : null,
        seat: { row: t.row_label, col: t.col_number, type: t.seat_type }
      }))
    });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// ========== SCAN: POST /api/tickets/scan ==========
router.post('/tickets/scan', async (req, res) => {
  const showtimeId = Number(req.body?.showtimeId);
  const qrCode = String(req.body?.qrCode || '').trim().toUpperCase();
  if (!showtimeId || !qrCode) return bad(res, 'BAD_REQUEST', 'showtimeId v√† qrCode l√† b·∫Øt bu·ªôc');

  try {
    const [upd] = await pool.query(
      `UPDATE tickets
          SET status='SCANNED', scanned_at=UTC_TIMESTAMP()
        WHERE showtime_id=? AND qr_code=? AND status='ISSUED'`,
      [showtimeId, qrCode]
    );

    if (upd.affectedRows === 1) {
      const [[t]] = await pool.query(
        `SELECT tk.id, tk.order_id, tk.showtime_id, tk.seat_id, tk.status, tk.scanned_at, tk.qr_code,
                s.row_label, s.col_number, s.seat_type
           FROM tickets tk
           JOIN seats s ON s.id = tk.seat_id
          WHERE tk.showtime_id=? AND tk.qr_code=?
          LIMIT 1`, [showtimeId, qrCode]
      );
      res.setHeader('Cache-Control', 'no-store');
      return res.json({
        id: Number(t.id),
        orderId: Number(t.order_id),
        showtimeId: Number(t.showtime_id),
        seatId: Number(t.seat_id),
        status: t.status,
        scannedAt: t.scanned_at ? new Date(t.scanned_at).toISOString() : null,
        qrCode: t.qr_code,
        seat: { row: t.row_label, col: t.col_number, type: t.seat_type }
      });
    }

    const [[ex]] = await pool.query(
      `SELECT tk.id, tk.order_id, tk.status, tk.scanned_at
         FROM tickets tk
        WHERE tk.showtime_id=? AND tk.qr_code=?
        LIMIT 1`, [showtimeId, qrCode]
    );
    if (!ex) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y v√©', 404);
    if (ex.status === 'SCANNED' || ex.scanned_at) return bad(res, 'ALREADY_SCANNED', 'V√© ƒë√£ qu√©t r·ªìi', 409);
    return bad(res, 'INVALID_STATE', `Tr·∫°ng th√°i v√© kh√¥ng h·ª£p l·ªá: ${ex.status}`, 409);
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// ========== STATUS: GET /api/tickets/status ==========
router.get('/tickets/status', async (req, res) => {
  const showtimeId = Number(req.query.showtimeId);
  const qr = String(req.query.qr || '').trim().toUpperCase();
  if (!showtimeId || !qr) return bad(res, 'BAD_REQUEST', 'showtimeId v√† qr l√† b·∫Øt bu·ªôc');

  try {
    const [[t]] = await pool.query(
      `SELECT tk.id, tk.order_id, tk.seat_id, tk.status, tk.scanned_at,
              s.row_label, s.col_number, s.seat_type
         FROM tickets tk
         JOIN seats s ON s.id = tk.seat_id
        WHERE tk.showtime_id=? AND tk.qr_code=?
        LIMIT 1`, [showtimeId, qr]
    );
    if (!t) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y v√©', 404);

    res.setHeader('Cache-Control', 'no-store');
    return res.json({
      found: true,
      status: t.status,
      ticket: {
        id: Number(t.id),
        orderId: Number(t.order_id),
        seatId: Number(t.seat_id),
        scannedAt: t.scanned_at ? new Date(t.scanned_at).toISOString() : null,
        seat: { row: t.row_label, col: t.col_number, type: t.seat_type }
      }
    });
  } catch (e) {
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

module.exports = router;

```

### routes\tmdb.js
```js
// server/routes/tmdb.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

// TMDB config
const API = 'https://api.themoviedb.org/3';
const KEY = process.env.TMDB_API_KEY || '';

// helpers
const qs = (o) =>
  new URLSearchParams({ api_key: KEY, include_adult: 'false', ...o }).toString();
const bad = (res, code, message, status = 400, extra = {}) =>
  res.status(status).json({ error: code, message, ...extra });

async function j(url) {
  const r = await fetch(url, { headers: { Accept: 'application/json' } });
  if (!r.ok) throw new Error(`TMDB_${r.status}`);
  return r.json();
}
async function getMoviePack(id, lang) {
  // videos + release_dates (ƒë·ªô tu·ªïi) + external_ids (imdb_id)
  return j(
    `${API}/movie/${id}?${qs({
      language: lang,
      append_to_response: 'videos,release_dates,external_ids',
    })}`
  );
}
function pickTrailer(results = []) {
  const ys = results.filter((v) => v.site === 'YouTube');
  return (
    ys.find((v) => v.type === 'Trailer' && v.official) ||
    ys.find((v) => v.type === 'Trailer') ||
    ys[0] ||
    null
  );
}
function pickCert(buckets = []) {
  const by = (code) => buckets.find((b) => b.iso_3166_1 === code);
  const cert = (b) =>
    b?.release_dates?.find((x) => (x.certification || '').trim())?.certification || null;
  return cert(by('VN')) || cert(by('US')) || cert(buckets[0]) || null;
}
// DB enum ch·ªâ cho ph√©p: Trailer | Teaser | Clip
function mapVideoKind(t) {
  const s = String(t || '').toUpperCase();
  if (s === 'TRAILER') return 'Trailer';
  if (s === 'TEASER') return 'Teaser';
  return 'Clip';
}

// ========== SEARCH ==========
router.get('/tmdb/search', async (req, res) => {
  try {
    if (!KEY) return bad(res, 'TMDB_KEY', 'Thi·∫øu TMDB_API_KEY', 500);
    const query = String(req.query.query || '').trim();
    if (!query) return res.json({ items: [] });
    const page = Math.max(1, Number(req.query.page || 1));

    const data = await j(`${API}/search/movie?${qs({ query, page, language: 'vi-VN' })}`);
    const items = (data.results || []).map((m) => ({
      tmdbId: m.id,
      title: m.title,
      releaseDate: m.release_date || null,
      posterPath: m.poster_path || null,
      backdropPath: m.backdrop_path || null,
      overview: m.overview || null,
      voteAverage: m.vote_average ?? null,
      voteCount: m.vote_count ?? null,
    }));
    res.json({ items });
  } catch (e) {
    bad(res, 'TMDB_BAD_GATEWAY', String(e.message || e), 502);
  }
});

// ========== LIST CATALOG (now_playing | popular | top_rated | upcoming) ==========
router.get('/tmdb/list', async (req, res) => {
  try {
    if (!KEY) return bad(res, 'TMDB_KEY', 'Thi·∫øu TMDB_API_KEY', 500);
    const cat = String(req.query.cat || 'now_playing').toLowerCase();
    const page = Math.max(1, Number(req.query.page || 1));
    const allow = new Set(['now_playing', 'popular', 'top_rated', 'upcoming']);
    const use = allow.has(cat) ? cat : 'now_playing';

    const data = await j(`${API}/movie/${use}?${qs({ language: 'vi-VN', page })}`);
    const items = (data.results || []).map((m) => ({
      tmdbId: m.id,
      title: m.title,
      releaseDate: m.release_date || null,
      posterPath: m.poster_path || null,
      backdropPath: m.backdrop_path || null,
      overview: m.overview || null,
      voteAverage: m.vote_average ?? null,
      voteCount: m.vote_count ?? null,
    }));
    res.json({ page: data.page || page, totalPages: data.total_pages || 1, items });
  } catch (e) {
    bad(res, 'TMDB_BAD_GATEWAY', String(e.message || e), 502);
  }
});

// ========== DETAIL (fallback vi-VN -> en-US) ==========
router.get('/tmdb/movie/:id', async (req, res) => {
  try {
    if (!KEY) return bad(res, 'TMDB_KEY', 'Thi·∫øu TMDB_API_KEY', 500);
    const id = Number(req.params.id || 0);
    if (!id) return bad(res, 'BAD_REQUEST', 'tmdbId kh√¥ng h·ª£p l·ªá');

    const vi = await getMoviePack(id, 'vi-VN');
    const en = await getMoviePack(id, 'en-US').catch(() => null);

    const title = (vi.title && vi.title.trim()) ? vi.title : en?.title || vi.title;
    const overview = (vi.overview && vi.overview.trim()) ? vi.overview : en?.overview || null;
    const runtime = vi.runtime || en?.runtime || 0;
    const releaseDate = vi.release_date || en?.release_date || null;
    const posterPath = vi.poster_path || en?.poster_path || null;
    const backdropPath = vi.backdrop_path || en?.backdrop_path || null;
    const voteAverage = vi.vote_average ?? en?.vote_average ?? null;
    const voteCount = vi.vote_count ?? en?.vote_count ?? null;
    const popularity = vi.popularity ?? en?.popularity ?? null;
    const imdbId = vi.external_ids?.imdb_id || en?.external_ids?.imdb_id || null;
    const originalTitle = vi.original_title || en?.original_title || null;
    const originalLanguage = vi.original_language || en?.original_language || null;
    const genresArr = (vi.genres?.length ? vi.genres : en?.genres || []).map((g) => g.name);
    const videosAll = (vi.videos?.results || []).concat(en?.videos?.results || []);
    const trailer = pickTrailer(videosAll);
    const ratingAge = pickCert(
      (vi.release_dates?.results || []).concat(en?.release_dates?.results || [])
    );

    res.json({
      tmdbId: vi.id,
      title,
      overview,
      runtime,
      releaseDate,
      posterPath,
      backdropPath,
      voteAverage,
      voteCount,
      popularity,
      imdbId,
      originalTitle,
      originalLanguage,
      genres: genresArr,
      ratingAge: ratingAge || null,
      trailer: trailer
        ? { site: trailer.site, key: trailer.key, url: `https://www.youtube.com/watch?v=${trailer.key}` }
        : null,
    });
  } catch {
    bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y tr√™n TMDB', 404);
  }
});

// ========== IMPORT (upsert + videos, genres JSON) ==========
router.post('/tmdb/import/:id', async (req, res) => {
  if (!KEY) return bad(res, 'TMDB_KEY', 'Thi·∫øu TMDB_API_KEY', 500);
  const tmdbId = Number(req.params.id || 0);
  if (!tmdbId) return bad(res, 'BAD_REQUEST', 'tmdbId kh√¥ng h·ª£p l·ªá');

  const conn = await pool.getConnection();
  try {
    const vi = await getMoviePack(tmdbId, 'vi-VN');
    const en = await getMoviePack(tmdbId, 'en-US').catch(() => null);

    const title = (vi.title && vi.title.trim()) ? vi.title : en?.title || vi.title;
    const overview = (vi.overview && vi.overview.trim()) ? vi.overview : en?.overview || null;
    const runtime = vi.runtime || en?.runtime || 0;
    const releaseDate = vi.release_date || en?.release_date || null;
    const posterPath = vi.poster_path || en?.poster_path || null;
    const backdropPath = vi.backdrop_path || en?.backdrop_path || null;
    const voteAverage = vi.vote_average ?? en?.vote_average ?? null;
    const voteCount = vi.vote_count ?? en?.vote_count ?? null;
    const popularity = vi.popularity ?? en?.popularity ?? null;
    const imdbId = vi.external_ids?.imdb_id || en?.external_ids?.imdb_id || null;
    const originalTitle = vi.original_title || en?.original_title || null;
    const originalLanguage = vi.original_language || en?.original_language || null;
    const genresArr = (vi.genres?.length ? vi.genres : en?.genres || []).map((g) => g.name);
    const genresJson = genresArr.length ? JSON.stringify(genresArr) : null;

    const videosAll = (vi.videos?.results || []).concat(en?.videos?.results || []);
    const trailer = pickTrailer(videosAll);
    const trailerUrl = trailer ? `https://www.youtube.com/watch?v=${trailer.key}` : null;
    const ratingAge = pickCert(
      (vi.release_dates?.results || []).concat(en?.release_dates?.results || [])
    );

    await conn.beginTransaction();

    // upsert movies
    await conn.query(
      `INSERT INTO movies
       (tmdb_id, title, status, duration_min, rating_age, genres, release_date, trailer_url, description,
        imdb_id, original_title, original_language, poster_path, backdrop_path, popularity, vote_average, vote_count,
        created_at, updated_at)
       VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,UTC_TIMESTAMP(),UTC_TIMESTAMP())
       ON DUPLICATE KEY UPDATE
         title=VALUES(title),
         duration_min=VALUES(duration_min),
         rating_age=VALUES(rating_age),
         genres=VALUES(genres),
         release_date=VALUES(release_date),
         trailer_url=VALUES(trailer_url),
         description=VALUES(description),
         imdb_id=VALUES(imdb_id),
         original_title=VALUES(original_title),
         original_language=VALUES(original_language),
         poster_path=VALUES(poster_path),
         backdrop_path=VALUES(backdrop_path),
         popularity=VALUES(popularity),
         vote_average=VALUES(vote_average),
         vote_count=VALUES(vote_count),
         updated_at=UTC_TIMESTAMP()`,
      [
        tmdbId,
        title,
        'NOW',
        Number(runtime || 0),
        ratingAge || null,
        genresJson,
        releaseDate || null,
        trailerUrl,
        overview,
        imdbId,
        originalTitle,
        originalLanguage,
        posterPath,
        backdropPath,
        popularity,
        voteAverage,
        voteCount,
      ]
    );

    // id trong DB
    const [[row]] = await conn.query(`SELECT id FROM movies WHERE tmdb_id=?`, [tmdbId]);
    const movieId = Number(row.id);

    // videos: replace all, ch·ªâ YouTube, map kind ƒë√∫ng ENUM
    await conn.query(`DELETE FROM movie_videos WHERE movie_id=?`, [movieId]);
    const ys = videosAll.filter((v) => v.site === 'YouTube');
    if (ys.length) {
      const values = ys.slice(0, 50).map((v) => [
        movieId,
        'YouTube',
        mapVideoKind(v.type),
        v.key,
        v.published_at ? new Date(v.published_at) : null,
      ]);
      await conn.query(
        `INSERT INTO movie_videos (movie_id, site, kind, key_or_url, published_at) VALUES ?`,
        [values]
      );
    }

    await conn.commit();
    res.json({ imported: true, movieId });
  } catch (e) {
    await conn.rollback();
    bad(res, 'INTERNAL', String(e.message || e), 500);
  } finally {
    conn.release();
  }
});

module.exports = router;

```

### routes\users.js
```js
// server/routes/users.js
const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const { pool } = require('../src/db');

const bad = (res, code, message, status = 400, extra = {}) =>
  res.status(status).json({ error: code, message, ...extra });

const normEmail = (e) => String(e || '').trim().toLowerCase();
const normStr = (s) => String(s || '').trim();

// ---------- Helpers ----------
async function getUser(id) {
  const [[u]] = await pool.query(
    `SELECT id,name,email,phone,role,is_active,created_at FROM users WHERE id=?`,
    [id]
  );
  return u || null;
}
function toDto(u) {
  return {
    id: Number(u.id),
    email: u.email,
    fullName: u.name,
    phone: u.phone,
    role: u.role,
    isActive: !!u.is_active,
    createdAt: u.created_at,
  };
}

// ---------- Admin: list/search ----------
router.get('/users', async (req, res) => {
  const q = normStr(req.query.q || '');
  const where = [];
  const args = [];
  if (q) {
    where.push(`(email LIKE ? OR name LIKE ? OR phone LIKE ?)`);
    args.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }
  const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';
  const [rows] = await pool.query(
    `SELECT id,name,email,phone,role,is_active,created_at
     FROM users ${whereSql}
     ORDER BY id DESC LIMIT 500`,
    args
  );
  res.json({ items: rows.map(toDto) });
});

// ---------- Admin: create ----------
router.post('/users', async (req, res) => {
  const email = normEmail(req.body?.email);
  const name = normStr(req.body?.fullName || req.body?.name);
  const phone = normStr(req.body?.phone || null) || null;
  const role = String(req.body?.role || 'USER').toUpperCase();
  const isActive = req.body?.isActive === false ? 0 : 1;
  const rawPwd = normStr(req.body?.password);
  const validRole = new Set(['ADMIN', 'STAFF', 'USER']);
  if (!email || !name) return bad(res, 'BAD_REQUEST', 'email, fullName b·∫Øt bu·ªôc');
  if (!validRole.has(role)) return bad(res, 'BAD_REQUEST', 'role kh√¥ng h·ª£p l·ªá');

  const [[e1]] = await pool.query(`SELECT id FROM users WHERE email=?`, [email]);
  if (e1) return bad(res, 'EMAIL_EXISTS', 'Email ƒë√£ t·ªìn t·∫°i', 409);
  if (phone) {
    const [[p1]] = await pool.query(`SELECT id FROM users WHERE phone=?`, [phone]);
    if (p1) return bad(res, 'PHONE_EXISTS', 'S·ªë ƒëi·ªán tho·∫°i ƒë√£ t·ªìn t·∫°i', 409);
  }

  const tempPassword = rawPwd || Math.random().toString(36).slice(-8);
  const hash = await bcrypt.hash(tempPassword, 10);

  const [r] = await pool.query(
    `INSERT INTO users(name,email,phone,password_hash,role,is_active,created_at,updated_at)
     VALUES(?,?,?,?,?,?,UTC_TIMESTAMP(),UTC_TIMESTAMP())`,
    [name, email, phone, hash, role, isActive]
  );
  const u = await getUser(r.insertId);
  res.json({ ...toDto(u), tempPassword });
});

// ---------- Admin: update/toggle ----------
router.put('/users/:id', async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');
  const u = await getUser(id);
  if (!u) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y user', 404);

  const sets = [];
  const args = [];

  if (req.body?.email !== undefined) {
    const email = normEmail(req.body.email);
    if (!email) return bad(res, 'BAD_REQUEST', 'email kh√¥ng h·ª£p l·ªá');
    const [[e2]] = await pool.query(`SELECT id FROM users WHERE email=? AND id<>?`, [email, id]);
    if (e2) return bad(res, 'EMAIL_EXISTS', 'Email ƒë√£ t·ªìn t·∫°i', 409);
    sets.push('email=?'); args.push(email);
  }
  if (req.body?.fullName !== undefined || req.body?.name !== undefined) {
    const name = normStr(req.body.fullName ?? req.body.name);
    if (!name) return bad(res, 'BAD_REQUEST', 'fullName kh√¥ng h·ª£p l·ªá');
    sets.push('name=?'); args.push(name);
  }
  if (req.body?.phone !== undefined) {
    const phone = normStr(req.body.phone || null) || null;
    if (phone) {
      const [[p2]] = await pool.query(`SELECT id FROM users WHERE phone=? AND id<>?`, [phone, id]);
      if (p2) return bad(res, 'PHONE_EXISTS', 'S·ªë ƒëi·ªán tho·∫°i ƒë√£ t·ªìn t·∫°i', 409);
    }
    sets.push('phone=?'); args.push(phone);
  }
  if (req.body?.role !== undefined) {
    const role = String(req.body.role || '').toUpperCase();
    if (!['ADMIN', 'STAFF', 'USER'].includes(role)) return bad(res, 'BAD_REQUEST', 'role kh√¥ng h·ª£p l·ªá');
    sets.push('role=?'); args.push(role);
  }
  if (req.body?.isActive !== undefined) {
    sets.push('is_active=?'); args.push(req.body.isActive ? 1 : 0);
  }
  if (req.body?.password) {
    const hash = await bcrypt.hash(String(req.body.password), 10);
    sets.push('password_hash=?'); args.push(hash);
  }
  if (!sets.length) return bad(res, 'BAD_REQUEST', 'Kh√¥ng c√≥ thay ƒë·ªïi');

  sets.push('updated_at=UTC_TIMESTAMP()');
  args.push(id);
  await pool.query(`UPDATE users SET ${sets.join(', ')} WHERE id=?`, args);
  const nu = await getUser(id);
  res.json(toDto(nu));
});

// ---------- Admin: delete ----------
router.delete('/users/:id', async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');
  const u = await getUser(id);
  if (!u) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y user', 404);
  await pool.query(`DELETE FROM users WHERE id=?`, [id]); // orders.user_id ON DELETE SET NULL
  res.json({ ok: true });
});

// ---------- Public: register ----------
router.post('/users/register', async (req, res) => {
  const name = normStr(req.body?.name);
  const email = normEmail(req.body?.email);
  const password = String(req.body?.password || '');
  if (!name || !email || !password) return bad(res, 'BAD_REQUEST', 'Thi·∫øu th√¥ng tin');
  if (password.length < 4) return bad(res, 'WEAK_PASSWORD', 'M·∫≠t kh·∫©u ph·∫£i t·ª´ 4 k√Ω t·ª±');

  const [[exists]] = await pool.query(`SELECT id FROM users WHERE email=?`, [email]);
  if (exists) return bad(res, 'EMAIL_EXISTS', 'Email ƒë√£ t·ªìn t·∫°i', 409);

  const hash = await bcrypt.hash(password, 10);
  const [r] = await pool.query(
    `INSERT INTO users (name,email,phone,password_hash,role,is_active,created_at,updated_at)
     VALUES (?,?,NULL,?,'USER',1,UTC_TIMESTAMP(),UTC_TIMESTAMP())`,
    [name, email, hash]
  );
  res.json({ id: r.insertId, name, email, role: 'USER' });
});

// ---------- Public: login ----------
router.post('/users/login', async (req, res) => {
  const email = normEmail(req.body?.email);
  const password = String(req.body?.password || '');
  if (!email || !password) return bad(res, 'BAD_REQUEST', 'Thi·∫øu th√¥ng tin');

  const [[u]] = await pool.query(
    `SELECT id,name,email,password_hash,role,is_active FROM users WHERE email=?`,
    [email]
  );
  if (!u || !u.password_hash) return bad(res, 'INVALID_CREDENTIALS', 'Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u', 401);
  if (!u.is_active) return bad(res, 'INACTIVE_USER', 'T√†i kho·∫£n b·ªã kh√≥a', 403);

  const dbHash = String(u.password_hash || '').trim();
  const match = await bcrypt.compare(password, dbHash);
  if (!match) return bad(res, 'INVALID_CREDENTIALS', 'Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u', 401);

  res.json({ id: u.id, name: u.name, email: u.email, role: u.role });
});

// ---------- Seed ADMIN once ----------
router.post('/users/seed-admin', async (req, res) => {
  const name = normStr(req.body?.name || 'Admin');
  const email = normEmail(req.body?.email);
  const password = String(req.body?.password || '');
  if (!email || !password) return bad(res, 'BAD_REQUEST', 'Thi·∫øu email/password');

  const [[{ cnt }]] = await pool.query(`SELECT COUNT(*) AS cnt FROM users WHERE role='ADMIN'`);
  if (cnt > 0) return bad(res, 'ADMIN_EXISTS', 'ƒê√£ c√≥ ADMIN', 409);

  const hash = await bcrypt.hash(password, 10);
  const [r] = await pool.query(
    `INSERT INTO users (name,email,phone,password_hash,role,is_active,created_at,updated_at)
     VALUES (?,?,NULL,?,'ADMIN',1,UTC_TIMESTAMP(),UTC_TIMESTAMP())`,
    [name, email, hash]
  );
  res.json({ id: r.insertId, name, email, role: 'ADMIN' });
});

module.exports = router;

```

### routes\vouchers.js
```js
// server/routes/vouchers.js
const express = require('express');
const router = express.Router();
const { pool } = require('../src/db');

function bad(res, code, message, status = 400, extra = {}) {
  return res.status(status).json({ error: code, message, ...extra });
}
function isoToMysql(iso) {
  if (!iso) return null;
  const d = new Date(iso);
  if (isNaN(d.getTime())) return null;
  const pad = n => String(n).padStart(2, '0');
  return `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())} ${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}:${pad(d.getUTCSeconds())}`;
}
function mapRow(r) {
  return {
    id: r.id,
    code: r.code,
    kind: r.kind,
    value: Number(r.value),
    minTotal: Number(r.min_total),
    expiryAt: r.expiry_at ? new Date(r.expiry_at).toISOString() : null,
    quota: r.quota == null ? null : Number(r.quota),
    perUserLimit: Number(r.per_user_limit),
    isActive: !!r.is_active,
    createdAt: r.created_at,
    updatedAt: r.updated_at
  };
}
const ABC = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // b·ªè 0,O,1,I
function randomCode(len = 10) {
  let s = '';
  for (let i = 0; i < len; i++) s += ABC[Math.floor(Math.random()*ABC.length)];
  return s;
}
async function uniqueCode(conn, len = 10, maxTry = 8) {
  for (let i = 0; i < maxTry; i++) {
    const code = randomCode(len);
    const [[ex]] = await conn.query(`SELECT id FROM vouchers WHERE code=? LIMIT 1`, [code]);
    if (!ex) return code;
  }
  throw new Error('GEN_CODE_FAILED');
}

// GET /api/vouchers
router.get('/vouchers', async (req, res) => {
  const page = Math.max(1, Number(req.query.page) || 1);
  const pageSize = Math.min(200, Math.max(1, Number(req.query.pageSize) || 100));
  const q = String(req.query.q || '').trim();
  const active = String(req.query.active || '').toLowerCase();

  const where = [];
  const args = [];
  if (q) { where.push('(code LIKE ?)'); args.push('%'+q+'%'); }
  if (active === 'true') where.push('is_active=1');
  if (active === 'false') where.push('is_active=0');
  const whereSql = where.length ? 'WHERE ' + where.join(' AND ') : '';

  try {
    const [[{ total }]] = await pool.query(`SELECT COUNT(*) AS total FROM vouchers ${whereSql}`, args);
    const [rows] = await pool.query(
      `SELECT * FROM vouchers ${whereSql} ORDER BY id DESC LIMIT ? OFFSET ?`,
      [...args, pageSize, (page-1)*pageSize]
    );
    res.json({ items: rows.map(mapRow), total, page, pageSize });
  } catch (e) { return bad(res, 'INTERNAL', e.message, 500); }
});

// GET /api/vouchers/:id
router.get('/vouchers/:id', async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');
  try {
    const [[r]] = await pool.query(`SELECT * FROM vouchers WHERE id=?`, [id]);
    if (!r) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y', 404);
    res.json(mapRow(r));
  } catch (e) { return bad(res, 'INTERNAL', e.message, 500); }
});

// POST /api/vouchers  (code c√≥ th·ªÉ b·ªè tr·ªëng -> random duy nh·∫•t)
router.post('/vouchers', async (req, res) => {
  const b = req.body || {};
  const kind = String(b.kind || '').toUpperCase();
  const value = Number(b.value || 0);
  const minTotal = Number(b.minTotal || 0);
  const expiryAt = isoToMysql(b.expiryAt || null);
  const quota = b.quota === null || b.quota === '' || b.quota === undefined ? null : Number(b.quota);
  const perUserLimit = Number(b.perUserLimit || 1);
  const isActive = !!b.isActive;

  if (!['AMOUNT','PERCENT'].includes(kind)) return bad(res, 'BAD_REQUEST', 'kind kh√¥ng h·ª£p l·ªá');
  if (!(value > 0)) return bad(res, 'BAD_REQUEST', 'value ph·∫£i > 0');
  if (kind === 'PERCENT' && value > 100) return bad(res, 'BAD_REQUEST', 'percent ‚â§ 100');
  if (minTotal < 0) return bad(res, 'BAD_REQUEST', 'minTotal kh√¥ng h·ª£p l·ªá');
  if (!(perUserLimit >= 1)) return bad(res, 'BAD_REQUEST', 'perUserLimit ‚â• 1');

  const conn = await pool.getConnection();
  try {
    const codeIn = String(b.code || '').trim().toUpperCase();
    const code = codeIn || await uniqueCode(conn, 10);

    const [r] = await conn.query(
      `INSERT INTO vouchers (code, kind, value, min_total, expiry_at, quota, per_user_limit, is_active, created_at, updated_at)
       VALUES (?,?,?,?,?,?,?,?, UTC_TIMESTAMP(), UTC_TIMESTAMP())`,
      [code, kind, value, minTotal, expiryAt, quota, perUserLimit, isActive ? 1 : 0]
    );
    res.status(201).json({ id: Number(r.insertId), code });
  } catch (e) {
    if (String(e.code) === 'ER_DUP_ENTRY') return bad(res, 'DUPLICATE', 'Code ƒë√£ t·ªìn t·∫°i', 409);
    if (e.message === 'GEN_CODE_FAILED') return bad(res, 'INTERNAL', 'Kh√¥ng t·∫°o ƒë∆∞·ª£c code ng·∫´u nhi√™n', 500);
    return bad(res, 'INTERNAL', e.message, 500);
  } finally { conn.release(); }
});

// PUT /api/vouchers/:id
router.put('/vouchers/:id', async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');

  const b = req.body || {};
  const fields = [];
  const args = [];

  if (b.code !== undefined) {
    const c = String(b.code || '').trim().toUpperCase();
    if (!c) return bad(res, 'BAD_REQUEST', 'code kh√¥ng ƒë∆∞·ª£c r·ªóng');
    fields.push('code=?'); args.push(c);
  }
  if (b.kind !== undefined) {
    const k = String(b.kind).toUpperCase();
    if (!['AMOUNT','PERCENT'].includes(k)) return bad(res, 'BAD_REQUEST', 'kind kh√¥ng h·ª£p l·ªá');
    fields.push('kind=?'); args.push(k);
  }
  if (b.value !== undefined) {
    const v = Number(b.value);
    if (!(v > 0)) return bad(res, 'BAD_REQUEST', 'value ph·∫£i > 0');
    fields.push('value=?'); args.push(v);
  }
  if (b.minTotal !== undefined) {
    const mt = Number(b.minTotal);
    if (mt < 0) return bad(res, 'BAD_REQUEST', 'minTotal kh√¥ng h·ª£p l·ªá');
    fields.push('min_total=?'); args.push(mt);
  }
  if (b.expiryAt !== undefined) { fields.push('expiry_at=?'); args.push(isoToMysql(b.expiryAt)); }
  if (b.quota !== undefined) {
    const q = b.quota === null || b.quota === '' ? null : Number(b.quota);
    fields.push('quota=?'); args.push(q);
  }
  if (b.perUserLimit !== undefined) {
    const pu = Number(b.perUserLimit);
    if (!(pu >= 1)) return bad(res, 'BAD_REQUEST', 'perUserLimit ‚â• 1');
    fields.push('per_user_limit=?'); args.push(pu);
  }
  if (b.isActive !== undefined) { fields.push('is_active=?'); args.push(b.isActive ? 1 : 0); }
  if (!fields.length) return bad(res, 'BAD_REQUEST', 'Kh√¥ng c√≥ tr∆∞·ªùng c·∫≠p nh·∫≠t');

  try {
    const [r] = await pool.query(
      `UPDATE vouchers SET ${fields.join(', ')}, updated_at=UTC_TIMESTAMP() WHERE id=?`,
      [...args, id]
    );
    if (r.affectedRows === 0) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y', 404);
    res.json({ ok: true });
  } catch (e) {
    if (String(e.code) === 'ER_DUP_ENTRY') return bad(res, 'DUPLICATE', 'Code ƒë√£ t·ªìn t·∫°i', 409);
    return bad(res, 'INTERNAL', e.message, 500);
  }
});

// DELETE /api/vouchers/:id  (ch·∫∑n xo√° n·∫øu ƒë√£ ƒë∆∞·ª£c d√πng)
router.delete('/vouchers/:id', async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return bad(res, 'BAD_REQUEST', 'id kh√¥ng h·ª£p l·ªá');

  try {
    const [[v]] = await pool.query(`SELECT id FROM vouchers WHERE id=?`, [id]);
    if (!v) return bad(res, 'NOT_FOUND', 'Kh√¥ng t√¨m th·∫•y', 404);

    const [[u]] = await pool.query(`SELECT COUNT(*) AS usedCnt FROM voucher_usages WHERE voucher_id=?`, [id]);
    if (u && Number(u.usedCnt) > 0) return bad(res, 'IN_USE', 'Voucher ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng, kh√¥ng th·ªÉ xo√°', 409);

    await pool.query(`DELETE FROM vouchers WHERE id=?`, [id]);
    res.json({ ok: true });
  } catch (e) { return bad(res, 'INTERNAL', e.message, 500); }
});

module.exports = router;

```

### src\db.js
```js
// server/src/db.js
const mysql = require('mysql2/promise');

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  user: process.env.DB_USER,
  password: process.env.DB_PASS,
  database: process.env.DB_NAME,
  timezone: 'Z',          // √©p UTC
  dateStrings: true,      // tr·∫£ v·ªÅ DATETIME d·∫°ng "YYYY-MM-DD HH:MM:SS"
  waitForConnections: true,
  connectionLimit: 10,
});

(async () => {
  try { await pool.query("SET time_zone = '+00:00'"); } catch {}
})();

module.exports = { pool };

```

### src\index.js
```js
// server/src/index.js
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
dotenv.config();

const { pool } = require('./db');
const holdsRoutes = require('../routes/holds');
const ordersRoutes = require('../routes/orders');
const paymentsRoutes = require('../routes/payments');
const ticketsRoutes = require('../routes/tickets');
const refundsRoutes = require('../routes/refunds');
const reportsRoutes = require('../routes/reports');
const usersRoutes = require('../routes/users');
const moviesRoutes = require('../routes/movies');
const showtimesRoutes = require('../routes/showtimes');
const tmdbRoutes = require('../routes/tmdb'); 
const exhibitorsRoutes = require('../routes/exhibitors');
const branchesRoutes = require('../routes/branches');
const catalogRoutes = require('../routes/catalog');
const roomsRoutes = require('../routes/rooms');
const seatsRoutes = require('../routes/seats');
const vouchersRoutes = require('../routes/vouchers');

const app = express();
app.use(cors());
app.use(express.json());

app.get('/api/health', async (_req, res) => {
  try {
    const [r] = await pool.query('SELECT 1 AS ok');
    res.json({ ok: r[0].ok === 1 });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

app.use('/api', holdsRoutes);
app.use('/api', ordersRoutes);
app.use('/api', paymentsRoutes);
app.use('/api', ticketsRoutes);
app.use('/api', refundsRoutes);
app.use('/api', reportsRoutes);
app.use('/api', usersRoutes);
app.use('/api', moviesRoutes);
app.use('/api', showtimesRoutes);
app.use('/api', exhibitorsRoutes);
app.use('/api', branchesRoutes);
app.use('/api', tmdbRoutes); 
app.use('/api', catalogRoutes);
app.use('/api', roomsRoutes);
app.use('/api', seatsRoutes);
app.use('/api', vouchersRoutes);

setInterval(async () => {
  try { await pool.query('DELETE FROM seat_holds WHERE expire_at <= UTC_TIMESTAMP()'); } catch {}
}, 30000);

const port = Number(process.env.PORT || 4000);
app.listen(port, () => console.log(`BE running :${port}`));

```

### src\order_guard.js
```js
// server/src/order_guard.js
const pad=n=>n<10?'0'+n:''+n;
const toMySQL=v=>{ const d=new Date(v); return `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())} ${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}:${pad(d.getUTCSeconds())}`; };

async function ensureOrderOpen(conn, orderId) {
  const [[o]] = await conn.query(
    'SELECT id, status, expires_at FROM orders WHERE id=? FOR UPDATE',
    [orderId]
  );
  if (!o) throw Object.assign(new Error('ORDER_NOT_FOUND'), { status: 404 });
  const now = new Date();
  if (o.status !== 'pending') throw Object.assign(new Error('ORDER_NOT_PENDING'), { status: 409 });
  if (o.expires_at && now >= new Date(o.expires_at)) throw Object.assign(new Error('ORDER_EXPIRED'), { status: 409 });
  return o;
}

module.exports = { ensureOrderOpen, toMySQL };

```
